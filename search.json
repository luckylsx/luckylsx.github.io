[{"title":"git 提交信息规范","url":"/2021/04/11/git-commit-message/","content":"\n        <h2 id=\"您可以遵循的Git-commit消息约定！\"   >\n          <a href=\"#您可以遵循的Git-commit消息约定！\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#您可以遵循的Git-commit消息约定！\" class=\"headerlink\" title=\"您可以遵循的Git commit消息约定！\"></a>您可以遵循的Git commit消息约定！</h2>\n      <p>典型的git commit消息像下面这样</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"“类型”必须是以下提到的以下内容之一！\"   >\n          <a href=\"#“类型”必须是以下提到的以下内容之一！\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“类型”必须是以下提到的以下内容之一！\" class=\"headerlink\" title=\"“类型”必须是以下提到的以下内容之一！\"></a>“类型”必须是以下提到的以下内容之一！</h3>\n      <a id=\"more\"></a>\n\n<ul>\n<li>build: 建立相关的更改（例如：与npm相关/添加外部依赖项）</li>\n<li>chore: 外部用户看不到的代码更改（例如：更改为.gitignore文件或.prettierrc文件）</li>\n<li>feat: 新特性</li>\n<li>fix: bug修复</li>\n<li>docs: 与文档相关的改变</li>\n<li>refactor: 既不修复错误也不添加功能的代码。 （例如：您可以在语义更改（例如重命名变量/函数名称）时使用此功能）</li>\n<li>perf: 可以提高性能的代码</li>\n<li>style: 有关样式的代码</li>\n<li>test: 添加新测试或对现有测试进行更改</li>\n<li>update: 更新</li>\n<li>upgrade: 升级</li>\n<li>sponsors: 赞助相关</li>\n</ul>\n\n        <h3 id=\"“scope”-是可选的\"   >\n          <a href=\"#“scope”-是可选的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“scope”-是可选的\" class=\"headerlink\" title=\"“scope” 是可选的\"></a>“scope” 是可选的</h3>\n      <ul>\n<li>scope 必须是名词，并且代表代码库部分的部分</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://karma-runner.github.io/1.0/dev/git-commit-msg.html\" >请参阅此链接以获取与scope相关的示例</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"“subject”\"   >\n          <a href=\"#“subject”\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“subject”\" class=\"headerlink\" title=\"“subject”\"></a>“subject”</h3>\n      <ul>\n<li>使用命令式，现在时(如： 使用”add” 代替 “added” 或 “adds”)</li>\n<li>不要使用 “.” 结尾</li>\n<li>不要使用首字母大写方式</li>\n</ul>\n<p><strong><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/eslint/eslint/commits/master\" >请参阅此链接以获取更多实用的提交消息示例</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></strong></p>\n\n        <h3 id=\"References\"   >\n          <a href=\"#References\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#References\" class=\"headerlink\" title=\"References:\"></a>References:</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.conventionalcommits.org/en/v1.0.0/\" >https://www.conventionalcommits.org/en/v1.0.0/</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716\" >https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/fteem/git-semantic-commits\" >https://github.com/fteem/git-semantic-commits</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["mysql"],"tags":["git"]},{"title":"golang-gmp","url":"/2021/03/27/golang/","content":"<p>this is golang new test</p>\n","categories":["golang"]},{"title":"Hello World","url":"/2021/03/27/hello-world/","content":"<p>Welcome to <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/\" >Hexo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>! This is your very first post. Check <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/\" >documentation</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/troubleshooting.html\" >troubleshooting</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> or you can ask me on <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hexojs/hexo/issues\" >GitHub</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>.</p>\n\n        <h2 id=\"Quick-Start\"   >\n          <a href=\"#Quick-Start\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2>\n      \n        <h3 id=\"Create-a-new-post\"   >\n          <a href=\"#Create-a-new-post\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/writing.html\" >Writing</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"Run-server\"   >\n          <a href=\"#Run-server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/server.html\" >Server</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Generate-static-files\"   >\n          <a href=\"#Generate-static-files\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/generating.html\" >Generating</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Deploy-to-remote-sites\"   >\n          <a href=\"#Deploy-to-remote-sites\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/one-command-deployment.html\" >Deployment</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n"},{"title":"http vs https","url":"/2021/03/27/https/","content":"<p>Welcome to <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/\" >Hexo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>! This is your very first post. Check <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/\" >documentation</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/troubleshooting.html\" >troubleshooting</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> or you can ask me on <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hexojs/hexo/issues\" >GitHub</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>.</p>\n\n        <h2 id=\"Quick-Start\"   >\n          <a href=\"#Quick-Start\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2>\n      \n        <h3 id=\"Create-a-new-post\"   >\n          <a href=\"#Create-a-new-post\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/writing.html\" >Writing</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"Run-server\"   >\n          <a href=\"#Run-server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/server.html\" >Server</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Generate-static-files\"   >\n          <a href=\"#Generate-static-files\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/generating.html\" >Generating</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Deploy-to-remote-sites\"   >\n          <a href=\"#Deploy-to-remote-sites\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/one-command-deployment.html\" >Deployment</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n"},{"title":"http 准则","url":"/2021/05/27/http%E5%87%86%E5%88%99/","content":"\n        <h2 id=\"HTTP-准则\"   >\n          <a href=\"#HTTP-准则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-准则\" class=\"headerlink\" title=\"HTTP 准则\"></a>HTTP 准则</h2>\n      <p>本文档介绍了 Google API 如何与不同的 HTTP 版本和实现结合使用。</p>\n\n        <h2 id=\"使用传输协议-HTTP\"   >\n          <a href=\"#使用传输协议-HTTP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用传输协议-HTTP\" class=\"headerlink\" title=\"使用传输协议 (HTTP/*)\"></a>使用传输协议 (HTTP/*)</h2>\n      <a id=\"more\"></a>\n\n<p>本部分介绍 Cloud API 可用于在客户端和服务器之间进行通信的支持的传输协议（通常是某个版本的 HTTP），以及我们为您建议的协议使用方式。我们将在下一部分详细介绍请求和响应的结构。</p>\n\n        <h3 id=\"HTTP-语义\"   >\n          <a href=\"#HTTP-语义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-语义\" class=\"headerlink\" title=\"HTTP 语义\"></a>HTTP 语义</h3>\n      <p>开发 API 客户端代码时，请遵循标准 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc7231\" >HTTP 协议语义</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。服务器端代理或 API 堆栈可能仅支持标准 HTTP 功能的子集，并且还可能支持其向后兼容的版本。</p>\n<p>需要由 API 的服务器端实现处理的 HTTP 协议语义由服务器堆栈控制。仅当这些功能明确记录为 API 规范（例如缓存支持）的一部分时，才能依赖此类语义。</p>\n\n        <h3 id=\"HTTP-版本\"   >\n          <a href=\"#HTTP-版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-版本\" class=\"headerlink\" title=\"HTTP 版本\"></a>HTTP 版本</h3>\n      <p>客户端可以使用客户端平台或其客户端网络允许或者与服务器端代理协商的任何 HTTP/* 协议。支持的协议包括 HTTP/1.0、HTTP/1.1、SPDY/*、HTTP/2 和 QUIC。</p>\n<p>某些 API 功能可能只有较新版本的 HTTP 协议（例如服务器推送和优先级）才支持；部分功能仅使用 HTTP/2（例如全双工流式传输）完全指定。如果您需要将这些功能中的任何功能作为 API 规范的一部分，请注意不同 HTTP 版本的限制。</p>\n<p>通常，为了提高性能和网络故障的恢复能力，建议使用 HTTP/2。</p>\n\n        <h3 id=\"渠道\"   >\n          <a href=\"#渠道\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#渠道\" class=\"headerlink\" title=\"渠道\"></a>渠道</h3>\n      <p>信道是指 L4 网络连接（TCP 或 UDP 套接字）。客户端应用不应该针对在运行时中如何使用信道来提供 HTTP 请求作出任何假设。在几乎所有情况下，信道都是由代表服务器进程的代理来终止。</p>\n<p>对于 HTTP/1.1 客户端，应始终重复使用 TCP 连接 (Connection: Keep-Alive)；为了获得更好的性能，HTTP 客户端库也可能会管理连接池。请不要通过相同的 TCP 连接传递请求。如需了解详情，请参阅 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/httpwg/wiki/wiki/TCP\" >HTTP 和 TCP</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。</p>\n<p>现代浏览器都使用 SPDY/*、HTTP/2 或 QUIC 进行通信，它们通过单个信道多路传输请求。除非服务器实现限制来自单个客户端的并发 HTTP 请求数 例如，针对单个源的 100 个 HTTP/2 信息流），否则传统的连接限制 (2-10) 永远不应该成为问题。</p>\n\n        <h3 id=\"HTTPS\"   >\n          <a href=\"#HTTPS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3>\n      <p>客户端可以通过 API 规范支持的 HTTPS 或 HTTP 访问 API。TLS 协商和 TLS 版本对客户端应用是透明的。默认情况下，Google API 仅接受 HTTPS 流量。</p>\n\n        <h2 id=\"请求-响应格式\"   >\n          <a href=\"#请求-响应格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求-响应格式\" class=\"headerlink\" title=\"请求/响应格式\"></a>请求/响应格式</h2>\n      \n        <h3 id=\"请求网址\"   >\n          <a href=\"#请求网址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求网址\" class=\"headerlink\" title=\"请求网址\"></a>请求网址</h3>\n      <p>JSON-REST 映射支持网址编码形式的请求数据，HTTP 请求和响应主体使用 application/json 作为 Content-Type。HTTP 主体使用 JSON 数组来支持流式 RPC 方法，JSON 数组可能包含任意数量的 JSON 消息或错误状态 JSON 消息。</p>\n\n        <h3 id=\"长请求网址\"   >\n          <a href=\"#长请求网址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#长请求网址\" class=\"headerlink\" title=\"长请求网址\"></a>长请求网址</h3>\n      <p>网址具有实际长度限制，通常在 2k 到 8k 之间。此限制由一些浏览器和代理强制执行。如果您的 API 使用网址超过长度限制的 GET 请求，浏览器可能会拒绝此类请求。要避开此限制，客户端代码应使用 Content-Type 为 application/x-www-form-urlencoded 的 POST 请求，且 HTTP 标头为 X-HTTP-Method-Override: GET。该方法也适用于 DELETE 请求。</p>\n\n        <h3 id=\"HTTP-方法（动词）\"   >\n          <a href=\"#HTTP-方法（动词）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-方法（动词）\" class=\"headerlink\" title=\"HTTP 方法（动词）\"></a>HTTP 方法（动词）</h3>\n      <p>如果请求网址符合 REST 模型，则将其 HTTP 方法指定为 API 规范的一部分。特别是，每种 API 方法都必须符合基于 API 方法映射到的特定 HTTP 动词的 HTTP 协议的要求。如需了解详情，请参阅<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9\" >超文本传输协议</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>规范和 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc5789\" >PATCH 方法</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> RFC。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.1.1\" >安全方法</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（如 HTTP GET 和 HEAD）不应表示检索以外的操作。具体来说，HTTP GET 应该安全，不应对客户端产生任何显而易见的副作用。</p>\n<p>HTTP 中的<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.1.2\" >幂等性</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>意味着多个相同请求产生的副作用与单个请求相同。GET、PUT 和 DELETE 是与风格指南相关的幂等 HTTP 方法。请注意，幂等性仅通过服务器副作用的形式表示，并未指定有关响应的任何内容。特别是对于不存在的资源，DELETE 应该返回 404 (Not Found)。</p>\n<p>HTTP POST 和 PATCH 既不安全也不具有幂等性。（PATCH 在 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc5789\" >RFC 5789</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> 中引入）</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>HTTP 动词</th>\n<th>安全</th>\n<th>幂等</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.3\" >GET</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.6\" >PUT</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>是</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.7\" >DELETE</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>是</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.5\" >POST</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc5789\" >PATCH</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"负载格式\"   >\n          <a href=\"#负载格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#负载格式\" class=\"headerlink\" title=\"负载格式\"></a>负载格式</h3>\n      <ul>\n<li>请求和响应应共享相同的 Content-Type，除非请求是带有 application/x-www-form-urlencoded 主体的 GET 或 POST。</li>\n<li>JSON 在 application/json MIME 类型中受支持。从 proto3 到 JSON 的映射在 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\" >JSON 映射</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>中正式指定。</li>\n<li>根据用于将请求字段映射到查询参数的相同 REST 样式映射规则，可以使用表单参数 (POST) 代替网址查询参数 (GET)。支持的 Content-Type 为 application/x-www-form-urlencoded。</li>\n</ul>\n\n        <h2 id=\"流式\"   >\n          <a href=\"#流式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流式\" class=\"headerlink\" title=\"流式\"></a>流式</h2>\n      \n        <h3 id=\"半双工与全双工\"   >\n          <a href=\"#半双工与全双工\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#半双工与全双工\" class=\"headerlink\" title=\"半双工与全双工\"></a>半双工与全双工</h3>\n      <p>HTTP 是一种请求响应协议，允许通过面向信息流的不同传输协议（如 TCP (HTTP/1.x)）或其多路复用变体 (SPDY、HTTP/2、QUIC) 传递其请求或响应主体。</p>\n<p>作为客户端开发人员，您的应用可以采用流式传输模式生成请求主体，即客户端流式传输。同样地，应用也可以采用流式传输模式使用响应主体，即服务器流式传输。</p>\n<p>但是，HTTP 规范未指定在请求正文仍处于挂起状态时是否允许服务器流式传输回响应正文（错误响应除外）。这种语义称为全双工流式传输。尽管许多 HTTP 客户端/服务器/代理软件确实支持全双工流式传输，即使 HTTP/1.1 也支持，但为了避免出现任何互操作性问题，基于 HTTP 的 Cloud API 仅限于半双工流式传输。</p>\n<p>默认情况下，Cloud API 中的出价 Bidi 流式传输方法会采用全双工语义。 也就是说，使用 HTTP 调用这样的方法是不安全的。如果流式传输方法仅为半双工（由服务器强制执行），则 API 文档应明确指定半双工行为。</p>\n<p>对于浏览器客户端，标准 HTTP 语义进一步受浏览器网络 API 的限制。目前，浏览器仅通过 XHR 或 Fetch 支持服务器流式传输通常遵循传输级别的帧处理方式）。Fetch API 可以使用 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/whatwg/streams\" >whatwg 流</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。</p>\n<p>由于浏览器的限制，需要浏览器支持的 Cloud API 必须避免采用客户端流式传输以及全双工流式传输，或者为浏览器客户端提供单独的 API。</p>\n<p>一般来说，通过互联网进行客户端流式传输不如服务器流式传输有用。这是因为使用客户端流式传输通常会导致有状态服务，这会对负载平衡造成负面影响，让系统更容易出现故障或受到攻击。另一方面，服务器流式传输可能很有用，因为它可以显着减少有长时间 RTT 延迟的网络上的延迟时间。</p>\n\n        <h3 id=\"消息编码\"   >\n          <a href=\"#消息编码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#消息编码\" class=\"headerlink\" title=\"消息编码\"></a>消息编码</h3>\n      <p>JSON 消息在流式传输时将作为 JSON 消息数组进行编码。请求或响应正文将作为有效的 JSON MIME 类型保留。</p>\n<p>客户端流式传输编码示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &lt;length&gt; &lt;message-bytes&gt; 1 &lt;length&gt; &lt;message-bytes&gt;  … EOF</span><br></pre></td></tr></table></div></figure>\n<p>服务器流式传输编码示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &lt;length&gt; &lt;message-bytes&gt;  … 2 &lt;length&gt; &lt;status-bytes&gt; EOF</span><br></pre></td></tr></table></div></figure>\n<p>线级编码：StreamBody 的定义仅在其为字段“messages”分配 tag-id 时才有意义，而“status”对于正常消息将采用 1-2 字节的 varint 编码，因此总的编码开销为每条消息 2-3 个字节</p>\n<p>需要添加可选的填充字段，才能支持使用 base64 编码的流：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">message StreamBody &#123;</span><br><span class=\"line\">  repeated bytes message &#x3D; 1;</span><br><span class=\"line\">  google.rpc.Status status &#x3D; 2;</span><br><span class=\"line\">  repeated bytes padding &#x3D; 15;   &#x2F;&#x2F; max one-byte tag-id: xxx01111</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>错误消息应作为 JSON 或 protobuf 数组的最后一个元素附加，其格式与常规消息相同。</p>\n\n        <h2 id=\"状态管理\"   >\n          <a href=\"#状态管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h2>\n      <p>适用于客户端或服务器的任何 HTTP 版本中都很好地定义了半关闭行为，旨在向另一端发送主体已完成的信号。</p>\n<p>特别是，客户端代码在等待响应时可以自由完成请求。与之类似，当请求主体仍在写入服务器时，客户端可能会看到完成的响应。HTTP 标准要求客户端在以意外方式完成响应时（通常具有错误状态）中止或完成请求。这就是说，在正常情况下，服务器不应在客户端仍在发送请求时完成响应。</p>\n\n        <h3 id=\"取消\"   >\n          <a href=\"#取消\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#取消\" class=\"headerlink\" title=\"取消\"></a>取消</h3>\n      <p>通过取消支持，客户端能够在请求或响应仍在等待处理时中止请求。</p>\n<p>HTTP/1.* 客户端没有可靠的取消支持，因为客户端可在请求完成后随时关闭 TCP 连接，而不会中止请求/响应事务。采用 HTTP/1.1 的 TCP FIN 不应被解释为取消，即使连接被标记为保持 keep-alive (Connection: Keep-Alive) 也是如此。</p>\n<p>但在客户端关闭 TCP 连接后，如果服务器尝试将任何数据写入客户端，则会生成 RST，这会触发取消。</p>\n<p>另请注意，取消也是非流式传输 API 存在的问题。当响应涉及长轮询并且因此导致连接长时间保持空闲时，此问题尤其明显。</p>\n<p>SPDY、HTTP/2 和 QUIC 支持显式取消，尤其是与 go-away 消息结合使用。</p>\n\n        <h3 id=\"Keep-alive\"   >\n          <a href=\"#Keep-alive\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Keep-alive\" class=\"headerlink\" title=\"Keep-alive\"></a>Keep-alive</h3>\n      <p>通过 Keep-alive 支持，客户端或服务器能够检测到失败的对等体，即使在出现丢包或网络故障的情况下也是如此。</p>\n<p>HTTP/1.1 不提供 keep-alive 支持，因为 TCP keep-alive 不是一种可行的方法。</p>\n<p>QUIC 或 HTTP/2 提供特殊控制消息，旨在实现由应用（包括浏览器）提供的 keep-alive 支持。</p>\n<p>但是，实现可靠的 keep-alive 和故障检测将可能需要有一个客户端库，加上必要的服务器端支持：如果依赖将基本 HTTP 作为通信协议，通过互联网进行长期流式传输通常容易出错。</p>\n\n        <h2 id=\"流控制\"   >\n          <a href=\"#流控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流控制\" class=\"headerlink\" title=\"流控制\"></a>流控制</h2>\n      <p>流控制支持要求客户端将传输级流控制事件传播到客户端应用。实际的机制取决于客户端应用所使用的 HTTP 客户端 API 执行机制。例如，为了防止客户端或服务器过载，您需要使用显式流控制支持阻塞写入和读取或者非阻塞读取和写入，以便应用处理和遵循流控制事件。</p>\n<p>HTTP/1.1 依赖于 TCP 流控制。</p>\n<p>SPDY 和 HTTP/2 在流级别具有自己的流控制，由于请求通过单个 TCP 连接进行多路复用，因此它们在连接级别进一步受到 TCP 流控制的限制。</p>\n<p>QUIC 在 UDP 上运行，因此可以完全自行管理流控制。</p>\n","categories":["http"],"tags":["http","Google API"]},{"title":"一条sql语句的执行过程","url":"/2020/01/14/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","content":"<p>比如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from T where ID&#x3D;10；</span><br></pre></td></tr></table></div></figure>\n<p>要想知道这条语句在 MySQL 内部的执行过程，需要把 MySQL 拆解一下看看里面都有哪些“零件”，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p>\n<a id=\"more\"></a>\n\n<p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p>\n<p>MySQL 的逻辑架构图</p>\n<p><img src=\"/images/mysql/mysql_base.png\" alt=\"mysql_base\"></p>\n<p>大体来说，MySQL 可以分为 Server 层和存储引擎层。</p>\n<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>\n<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>\n<p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p>\n<p>从图中不难看出，不同的存储引擎共用一个Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>\n<p>连接器<br>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></div></figure>\n<p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p>\n<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>\n<ul>\n<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>\n<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>\n</ul>\n<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>\n<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>\n<p><img src=\"/images/mysql/mysql_processlist.png\" alt=\"mysql_processlist\"></p>\n<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>\n<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>\n<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>\n<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>\n<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>\n<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>\n<p>2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>\n<p><strong>查询缓存</strong></p>\n<p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p>\n<p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>\n<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>\n<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>\n<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>\n<p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">select SQL_CACHE * from T where ID&#x3D;10</span><br></pre></td></tr></table></div></figure>\n<p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p>\n<p><strong>分析器</strong></p>\n<p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p>\n<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p>\n<p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串 “T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>\n<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>\n<p>如果你的语句不对，就会收到 “You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; elect * from t where ID&#x3D;1;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1</span><br></pre></td></tr></table></div></figure>\n<p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>\n<p><strong>优化器</strong></p>\n<p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>\n<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join:</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t1 join t2 using(ID) where t1.c&#x3D;10 and t2.d&#x3D;20</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>\n<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>\n</ul>\n<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>\n<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>\n<p><strong>执行器</strong></p>\n<p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>\n<p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t1 where id&#x3D;10;</span><br><span class=\"line\">ERROR 1142(42000) SELECT commend denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></div></figure>\n<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p>\n<p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>\n<p>1.调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；<br>2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br>3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集作为结果集返回给客户端。</p>\n<p>至此，这个语句就执行完成了。</p>\n<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>\n<p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>\n<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相的。</p>\n","categories":["MYSQL"],"tags":["mysql"]},{"title":"索引为何使用B+树","url":"/2020/10/12/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8B+%E6%A0%91/","content":"\n        <h2 id=\"问题思考\"   >\n          <a href=\"#问题思考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h2>\n      <p>数据库索引的数据结构有很多种，比如：哈希索引、平衡二叉树索引、B树索引、B+树索引等等。</p>\n<p>目前最流行的是B+树索引，那大家有没有想过为什么是B+树索引最流行，为什么其他索引应用不广泛</p>\n\n        <h2 id=\"哈希索引\"   >\n          <a href=\"#哈希索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#哈希索引\" class=\"headerlink\" title=\"哈希索引\"></a>哈希索引</h2>\n      <a id=\"more\"></a>\n\n<p>hash大家应该非常的熟悉，就是我们老生常谈的HashMap里用到的技术。Hash索引其检索效率非常高，索引的检索可以一次定位。</p>\n<p>既然Hash索引的效率这么高，为什么都用Hash索引而还要使用B-Tree索引呢?</p>\n<p>这是因为虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：</p>\n\n        <h3 id=\"1-原因一：\"   >\n          <a href=\"#1-原因一：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-原因一：\" class=\"headerlink\" title=\"1. 原因一：\"></a>1. 原因一：</h3>\n      <p><strong>Hash索引不能使用范围查询</strong></p>\n<p>Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询(注意&lt;&gt;和＜＝＞是不同的操作），不能使用范围查询，例如WHERE price &gt; 100。</p>\n<p>由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤。</p>\n\n        <h3 id=\"2-原因二：\"   >\n          <a href=\"#2-原因二：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-原因二：\" class=\"headerlink\" title=\"2. 原因二：\"></a>2. 原因二：</h3>\n      <p><strong>Hash索引不能利用部分索引键查询。</strong></p>\n<p>对于复合索引，Hash索引在计算Hash值的时候，是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值。</p>\n<p>所以通过复合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。</p>\n\n        <h3 id=\"3-原因三：\"   >\n          <a href=\"#3-原因三：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-原因三：\" class=\"headerlink\" title=\"3. 原因三：\"></a>3. 原因三：</h3>\n      <p><strong>Hash索引在任何时候都不能避免表扫描。</strong></p>\n<p>Hash索引是将索引键通过Hash运算之后，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中。</p>\n<p>由于不同索引键存在相同Hash值，所以无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p>\n\n        <h2 id=\"平衡二叉树索引\"   >\n          <a href=\"#平衡二叉树索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#平衡二叉树索引\" class=\"headerlink\" title=\"平衡二叉树索引\"></a>平衡二叉树索引</h2>\n      <p>平衡二叉树的结构特点：</p>\n<p><img src=\"https://luckylsx.github.io/images/mysql/mysql_avl_tree.png\" alt=\"mysql_avl_tree\"></p>\n<p>又称 AVL树。它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它的左子树和右子树都是平衡二叉树。</p>\n<p>且左子树和右子树的深度之差的绝对值（平衡因子 ）不超过1。也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。</p>\n\n        <h3 id=\"被淘汰的原因\"   >\n          <a href=\"#被淘汰的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#被淘汰的原因\" class=\"headerlink\" title=\"被淘汰的原因:\"></a>被淘汰的原因:</h3>\n      <ul>\n<li>树的高度过高，高度越高，查找速度越慢</li>\n<li>他支持范围查找，但是他需要在进行回旋查找</li>\n</ul>\n<p>比如我要找到大于5的数据</p>\n<p>第一步我先定位到5，然后在树上按照二叉树规则去回旋查找大于5其他数据6、7、8、9、10。。。</p>\n<p>如果大于5的数据很多，那速度是很慢的。</p>\n\n        <h2 id=\"B树索引\"   >\n          <a href=\"#B树索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#B树索引\" class=\"headerlink\" title=\"B树索引\"></a>B树索引</h2>\n      <p><img src=\"https://luckylsx.github.io/images/mysql/mysql_b_tree.png\" alt=\"mysql_b_tree\"></p>\n<p>大家可以看到B树和二叉树最大的区别在于：它一个节点可以存储两个值，这就意味着它的树高度，比二叉树的高度更低，它的查询速度就更快。这是他的优点</p>\n<p>那为什么最终还是不用它呢，还是因为他在范围查找的时候，存在回旋查询的问题。同样order by排序的时候效率也很低，因为要把树上的数据手动排序一遍。</p>\n\n        <h2 id=\"终极大佬：B-树\"   >\n          <a href=\"#终极大佬：B-树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#终极大佬：B-树\" class=\"headerlink\" title=\"终极大佬：B+树:\"></a>终极大佬：B+树:</h2>\n      <p><img src=\"https://luckylsx.github.io/images/mysql/mysql_b_plus_tree.png\" alt=\"mysql_b_plus_tree\"></p>\n<p>它是B数的升级版，B+树相比B树，新增叶子节点与非叶子节点关系。</p>\n<p>叶子节点中包含了key和value，key存储的是1-10这些数字，value存储的是数据存储地址，非叶子节点中只是包含了key，不包含value。</p>\n<p>所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高</p>\n\n        <h3 id=\"比如我们要查找大于5的数据：\"   >\n          <a href=\"#比如我们要查找大于5的数据：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#比如我们要查找大于5的数据：\" class=\"headerlink\" title=\"比如我们要查找大于5的数据：\"></a>比如我们要查找大于5的数据：</h3>\n      <ul>\n<li>首先我们定位到5的位置</li>\n<li>然后直接将5后面的数据全部拿出来即可，因为这是有序链表，已经排好序了</li>\n</ul>\n<p>我们在order by排序的时候为什么要使用索引进行排序，原因就在这。</p>\n","categories":["mysql"],"tags":["mysql","B+树","hash"]},{"title":"在线小工具","url":"/2021/05/29/%E5%9C%A8%E7%BA%BF%E5%B0%8F%E5%B7%A5%E5%85%B7/","content":"<p>本文记录了编程人员常用的工具集合，方便自己编程使用，也作为小工具箱方便大家查找。</p>\n\n        <h3 id=\"工具转换\"   >\n          <a href=\"#工具转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#工具转换\" class=\"headerlink\" title=\"工具转换\"></a>工具转换</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.lu/timestamp/\" >时间戳</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.lu/\" >很全的在线工具集合</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.lu/markdown/\" >markdown在线编辑器</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.json.cn/\" >json格式化</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://oktools.net/json2go\" >json 转 struct</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.jisuapi.com/base642pic.html\" >base64 转图片</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://tool.chinaz.com/tools/regexgenerate\" >正则表达式生成</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tinypng.com/\" >图片压缩</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"查询类\"   >\n          <a href=\"#查询类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#查询类\" class=\"headerlink\" title=\"查询类\"></a>查询类</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ipaddress.com/\" >IP 地址查询</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.diffchecker.com/diff\" >内容差异比较</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://web.chacuo.net/netsslctcheck\" >网站证书信息查询</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><a href=\"www.jucha.com\">聚查网</a></li>\n</ul>\n\n        <h3 id=\"图标\"   >\n          <a href=\"#图标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.iconfont.cn/\" >阿里巴巴矢量图标库</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"在线作图\"   >\n          <a href=\"#在线作图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#在线作图\" class=\"headerlink\" title=\"在线作图\"></a>在线作图</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.processon.com/;jsessionid=63AD3093802D99FD12D81FBD3881824F.jvm1\" >ProcessOn</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"其他\"   >\n          <a href=\"#其他\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://idea.medeming.com/jet/\" >jetbrains激活码</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\" >nginx 证书生成</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://unbug.github.io/codelf/\" >中文智能转换变量</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://editor.mdnice.com/\" >微信公众号排版编辑</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.ddung.org/daili/\" >网站代理</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://xclient.info/\" >mac 软件下载</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://distrowatch.com/\" >开源操作系统最新信息</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["tool"],"tags":["tool"]},{"title":"MySQL数据库设计规范","url":"/2020/04/13/the-Mysql-Standards-Recommendation/","content":"\n        <h2 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 规范背景与目的\t</span><br><span class=\"line\"></span><br><span class=\"line\">2. 设计规范</span><br><span class=\"line\"></span><br><span class=\"line\">2.1 数据库设计\t</span><br><span class=\"line\"></span><br><span class=\"line\">2.1.1 库名\t</span><br><span class=\"line\">2.1.2 表结构\t</span><br><span class=\"line\">2.1.3 列数据类型优化\t</span><br><span class=\"line\">2.1.4 索引设计\t</span><br><span class=\"line\">2.1.5 分库分表、分区表\t</span><br><span class=\"line\">2.1.6 字符集\t</span><br><span class=\"line\">2.1.7 程序DAO层设计建议\t</span><br><span class=\"line\">2.1.8 一个规范的建表语句示例\t</span><br><span class=\"line\"></span><br><span class=\"line\">2.2 SQL编写\t</span><br><span class=\"line\"></span><br><span class=\"line\">2.2.1 DML语句\t</span><br><span class=\"line\">2.2.2 多表连接\t</span><br><span class=\"line\">2.2.3 事务\t</span><br><span class=\"line\">2.2.4 排序和分组\t</span><br><span class=\"line\">2.2.5 线上禁止使用的SQL语句</span><br></pre></td></tr></table></div></figure>\n<a id=\"more\"></a>\n\n\n\n        <h2 id=\"1-规范背景与目的\"   >\n          <a href=\"#1-规范背景与目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-规范背景与目的\" class=\"headerlink\" title=\"1. 规范背景与目的\"></a>1. 规范背景与目的</h2>\n      <p>MySQL数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。</p>\n\n        <h2 id=\"2-设计规范\"   >\n          <a href=\"#2-设计规范\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-设计规范\" class=\"headerlink\" title=\"2. 设计规范\"></a>2. 设计规范</h2>\n      \n        <h3 id=\"2-1-数据库设计\"   >\n          <a href=\"#2-1-数据库设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-数据库设计\" class=\"headerlink\" title=\"2.1 数据库设计\"></a>2.1 数据库设计</h3>\n      <p>以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。</p>\n<p>对于不满足【高危】和【强制】两个级别的设计，DBA会强制打回要求修改。</p>\n\n        <h4 id=\"2-1-1-库名\"   >\n          <a href=\"#2-1-1-库名\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-1-库名\" class=\"headerlink\" title=\"2.1.1 库名\"></a>2.1.1 库名</h4>\n      <p>1.【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量提现join的关系，如user表和user_login表。</p>\n<p>2.【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。</p>\n<p>3.【强制】一般分库名称命名格式是库通配名_编号，编号从0开始递增，比如wenda_001以时间进行分库的名称格式是“库通配名_时间”</p>\n<p>4.【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：create database db1 default character set utf8;。</p>\n\n        <h4 id=\"2-1-2-表结构\"   >\n          <a href=\"#2-1-2-表结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-2-表结构\" class=\"headerlink\" title=\"2.1.2 表结构\"></a>2.1.2 表结构</h4>\n      <p>1.【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。</p>\n<p>2.【强制】表名要求模块名强相关，如师资系统采用”sz”作为前缀，渠道系统采用”qd”作为前缀等。</p>\n<p>3.【强制】创建表时必须显式指定字符集为utf8或utf8mb4。</p>\n<p>4.【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB/MyISAM/Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB。</p>\n<p>5.【强制】建表必须有comment</p>\n<p>6.【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint，且为auto_increment。(2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引（可参考cdb.teacher表设计）。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降。</p>\n<p>7.【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段create_time和最后更新时间字段update_time，便于查问题。</p>\n<p>8.【建议】表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p>\n<p>9.【建议】建议对表里的blob、text等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select。</p>\n<p>10.【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如user_name属性在user_account，user_login_log等表里冗余一份，减少join查询。</p>\n<p>11.【强制】中间表用于保留中间结果集，名称必须以tmp_开头。备份表用于备份或抓取源表快照，名称必须以bak_开头。中间表和备份表定期清理。</p>\n<p>12.【强制】对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行。因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>\n\n        <h4 id=\"2-1-3-列数据类型优化\"   >\n          <a href=\"#2-1-3-列数据类型优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-3-列数据类型优化\" class=\"headerlink\" title=\"2.1.3 列数据类型优化\"></a>2.1.3 列数据类型优化</h4>\n      <p>1.【建议】表中的自增列（auto_increment属性），推荐使用bigint类型。因为无符号int存储范围为-2147483648~2147483647（大约21亿左右），溢出后会导致报错。</p>\n<p>2.【建议】业务中选择性很少的状态status、类型type等字段推荐使用tinytint或者smallint类型节省存储空间。</p>\n<p>3.【建议】业务中IP地址字段推荐使用int类型，不推荐用char(15)。因为int只占4字节，可以用如下函数相互转换，而char(15)占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。SQL：select inet_aton(‘192.168.2.12’); select inet_ntoa(3232236044); PHP: ip2long(‘192.168.2.12’); long2ip(3530427185);</p>\n<p>4.【建议】不推荐使用enum，set。因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用tinyint或smallint。</p>\n<p>5.【建议】不推荐使用blob，text等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段。Innodb中当一行记录超过8098字节时，会将该记录中选取最长的一个字段将其768字节放在原始page里，该字段余下内容放在overflow-page里。不幸的是在compact行格式下，原始page和overflow-page都会加载。</p>\n<p>6.【建议】存储金钱的字段，建议用int，程序端乘以100和除以100进行存取。因为int占用4字节，而double占用8字节，空间浪费。</p>\n<p>7.【建议】文本数据尽量用varchar存储。因为varchar是变长存储，比char更省空间。MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为mediumtext字段。而text在utf8字符集下最多存21844个字符，mediumtext最多存2^24/3个字符，longtext最多存2^32个字符。一般建议用varchar类型，字符数不要超过2700。</p>\n<p>8.【建议】时间类型尽量选取timestamp。因为datetime占用8字节，timestamp仅占用4字节，但是范围为1970-01-01 00:00:01到2038-01-01 00:00:00。更为高阶的方法，选用int来存储时间，使用SQL函数unix_timestamp()和from_unixtime()来进行转换。</p>\n<p>详细存储大小参加下图：</p>\n<p><img src=\"https://luckylsx.github.io/images/mysql/mysql_time_type.png\" alt=\"mysql_time_base\"></p>\n\n        <h4 id=\"2-1-4-索引设计\"   >\n          <a href=\"#2-1-4-索引设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-4-索引设计\" class=\"headerlink\" title=\"2.1.4 索引设计\"></a>2.1.4 索引设计</h4>\n      <p>1.【强制】InnoDB表必须主键为id int/bigint auto_increment,且主键值禁止被更新。</p>\n<p>2.【建议】主键的名称以“pk_”开头，唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀。</p>\n<p>3.【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引。</p>\n<p>4.【强制】单个索引中每个索引记录的长度不能超过64KB。</p>\n<p>5.【建议】单个表上的索引个数不能超过7个。</p>\n<p>6.【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列userid的区分度可由select count(distinct userid)计算出来。</p>\n<p>7.【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</p>\n<p>8.【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。</p>\n\n        <h4 id=\"2-1-5-分库分表、分区表\"   >\n          <a href=\"#2-1-5-分库分表、分区表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-5-分库分表、分区表\" class=\"headerlink\" title=\"2.1.5 分库分表、分区表\"></a>2.1.5 分库分表、分区表</h4>\n      <p>1.【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列。</p>\n<p>2.【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</p>\n<p>3.【强制】上线前RD或者DBA必须指定分区表的创建、清理策略。</p>\n<p>4.【强制】访问分区表的SQL必须包含分区键。</p>\n<p>5.【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个。</p>\n<p>6.【强制】对于分区表执行alter table操作，必须在业务低峰期执行。</p>\n<p>7.【强制】采用分库策略的，库的数量不能超过1024</p>\n<p>8.【强制】采用分表策略的，表的数量不能超过4096</p>\n<p>9.【建议】单个分表不超过500W行，ibd文件大小不超过2G，这样才能让数据分布式变得性能更佳。</p>\n<p>10.【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。</p>\n\n        <h4 id=\"2-1-6-字符集\"   >\n          <a href=\"#2-1-6-字符集\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-6-字符集\" class=\"headerlink\" title=\"2.1.6 字符集\"></a>2.1.6 字符集</h4>\n      <p>1.【强制】数据库本身库、表、列所有字符集必须保持一致，为utf8或utf8mb4。</p>\n<p>2.【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为utf8。</p>\n\n        <h4 id=\"2-1-7-程序层DAO设计建议\"   >\n          <a href=\"#2-1-7-程序层DAO设计建议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-7-程序层DAO设计建议\" class=\"headerlink\" title=\"2.1.7 程序层DAO设计建议\"></a>2.1.7 程序层DAO设计建议</h4>\n      <p>1.【建议】新的代码不要用model，推荐使用手动拼SQL+绑定变量传入参数的方式。因为model虽然可以使用面向对象的方式操作db，但是其使用不当很容易造成生成的SQL非常复杂，且model层自己做的强制类型转换性能较差，最终导致数据库性能下降。</p>\n<p>2.【建议】前端程序连接MySQL或者redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。</p>\n<p>3.【建议】前端程序报错里尽量能够提示MySQL或redis原生态的报错信息，便于排查错误。</p>\n<p>4.【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。</p>\n<p>5.【建议】对于log或history类型的表，随时间增长容易越来越大，因此上线前RD或者DBA必须建立表数据清理或归档方案。</p>\n<p>6.【建议】在应用程序设计阶段，RD必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。</p>\n<p>7.【建议】多个并发业务逻辑访问同一块数据（innodb表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类SQL尽量基于主键去更新。</p>\n<p>8.【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。</p>\n<p>9.【建议】对于单表读写比大于10:1的数据行或单个列，可以将热点数据放在缓存里（如mecache或redis），加快访问速度，降低MySQL压力。</p>\n\n        <h4 id=\"2-1-8-一个规范的建表语句示例\"   >\n          <a href=\"#2-1-8-一个规范的建表语句示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-8-一个规范的建表语句示例\" class=\"headerlink\" title=\"2.1.8 一个规范的建表语句示例\"></a>2.1.8 一个规范的建表语句示例</h4>\n      <p><strong>一个较为规范的建表语句为：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE user (</span><br><span class=\"line\">  &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  &#96;user_id&#96; bigint(11) NOT NULL COMMENT ‘用户id’</span><br><span class=\"line\">  &#96;username&#96; varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;,</span><br><span class=\"line\">  &#96;email&#96; varchar(30) NOT NULL COMMENT ‘用户邮箱’,</span><br><span class=\"line\">  &#96;nickname&#96; varchar(45) NOT NULL COMMENT &#39;昵称&#39;,</span><br><span class=\"line\">  &#96;avatar&#96; int(11) NOT NULL COMMENT &#39;头像&#39;,</span><br><span class=\"line\">  &#96;birthday&#96; date NOT NULL COMMENT &#39;生日&#39;,</span><br><span class=\"line\">  &#96;sex&#96; tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,</span><br><span class=\"line\">  &#96;short_introduce&#96; varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,</span><br><span class=\"line\">  &#96;user_resume&#96; varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,</span><br><span class=\"line\">  &#96;user_register_ip&#96; int NOT NULL COMMENT ‘用户注册时的源ip’,</span><br><span class=\"line\">  &#96;create_time&#96; timestamp NOT NULL COMMENT ‘用户记录创建的时间’,</span><br><span class=\"line\">  &#96;update_time&#96; timestamp NOT NULL COMMENT ‘用户资料修改的时间’,</span><br><span class=\"line\">  &#96;user_review_status&#96; tinyint NOT NULL COMMENT ‘用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核’,</span><br><span class=\"line\">  PRIMARY KEY (&#96;id&#96;),</span><br><span class=\"line\">  UNIQUE KEY &#96;idx_user_id&#96; (&#96;user_id&#96;),</span><br><span class=\"line\">  KEY &#96;idx_username&#96;(&#96;username&#96;),</span><br><span class=\"line\">  KEY &#96;idx_create_time&#96;(&#96;create_time&#96;,&#96;user_review_status&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;网站用户基本信息&#39;;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"2-2-SQL编写\"   >\n          <a href=\"#2-2-SQL编写\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-SQL编写\" class=\"headerlink\" title=\"2.2 SQL编写\"></a>2.2 SQL编写</h3>\n      \n        <h4 id=\"2-2-1-DML语句\"   >\n          <a href=\"#2-2-1-DML语句\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-1-DML语句\" class=\"headerlink\" title=\"2.2.1 DML语句\"></a>2.2.1 DML语句</h4>\n      <p>1.【强制】SELECT语句必须指定具体字段名称，禁止写成*。因为select *会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但model层没有来得及更新的话，系统会报错。</p>\n<p>2.【强制】insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上。</p>\n<p>3.【建议】insert into…values(XX),(XX),(XX)…。这里XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。</p>\n<p>4.【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。因为union all不需要去重，节省数据库资源，提高性能。</p>\n<p>5.【建议】in值列表限制在500以内。例如select… where userid in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</p>\n<p>6.【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。</p>\n<p>7.【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。</p>\n<p>8.【强制】写入和事务发往主库，只读SQL发往从库。</p>\n<p>9.【强制】除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。</p>\n<p>10.【强制】生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等。因为hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信MySQL优化器！</p>\n<p>11.【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</p>\n<p>12.【建议】SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找。</p>\n<p>13.【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引。</p>\n<p>14.【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</p>\n<p>15.【建议】索引列不要使用函数或表达式，否则无法利用索引。如where length(name)=’Admin’或where user_id+2=10023。</p>\n<p>16.【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索</p>\n<p>17.【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select a,b,c from t1 limit 10000,20;优化为: select a,b,c from t1 where id&gt;10000 limit 20;。</p>\n\n        <h4 id=\"2-2-2-多表连接\"   >\n          <a href=\"#2-2-2-多表连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-2-多表连接\" class=\"headerlink\" title=\"2.2.2 多表连接\"></a>2.2.2 多表连接</h4>\n      <p>1.【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。</p>\n<p>2.【强制】禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…。</p>\n<p>3.【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</p>\n<p>4.【建议】线上环境，多表join不要超过3个表。</p>\n<p>5.【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如select a from db1.table1 alias1 where …。</p>\n<p>6.【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</p>\n\n        <h4 id=\"2-2-3-事务\"   >\n          <a href=\"#2-2-3-事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-3-事务\" class=\"headerlink\" title=\"2.2.3 事务\"></a>2.2.3 事务</h4>\n      <p>1.【建议】事务中INSERT|UPDATE|DELETE|REPLACE语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内。</p>\n<p>2.【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值5-10秒。</p>\n<p>3.【建议】对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内。</p>\n<p>4.【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为repeatable-read。</p>\n<p>5.【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。</p>\n<p>6.【建议】事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p>\n<p>7.【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。</p>\n<p>8.【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库。</p>\n\n        <h4 id=\"2-2-4-排序和分组\"   >\n          <a href=\"#2-2-4-排序和分组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-4-排序和分组\" class=\"headerlink\" title=\"2.2.4 排序和分组\"></a>2.2.4 排序和分组</h4>\n      <p>1.【建议】减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p>\n<p>2.【建议】order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b)。</p>\n<p>3.【建议】包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p>\n\n        <h4 id=\"2-2-5-线上禁止使用的SQL语句\"   >\n          <a href=\"#2-2-5-线上禁止使用的SQL语句\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-5-线上禁止使用的SQL语句\" class=\"headerlink\" title=\"2.2.5 线上禁止使用的SQL语句\"></a>2.2.5 线上禁止使用的SQL语句</h4>\n      <p>1.【高危】禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK。</p>\n<p>2.【高危】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下。</p>\n<p>3.【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。</p>\n<p>4.【强制】禁用insert into …on duplicate key update…在高并发环境下，会造成主从不一致。</p>\n<p>5.【强制】禁用insert into …on duplicate key update…在高并发环境下，会造成主从不一致。</p>\n","categories":["MYSQL"],"tags":["mysq"]},{"title":"go实现各类限流算法","url":"/2021/05/30/go%E5%AE%9E%E7%8E%B0%E5%90%84%E7%B1%BB%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/","content":"\n        <h2 id=\"介绍\"   >\n          <a href=\"#介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2>\n      <p>限流是一种编程中常用的保护服务正常运行的一种方案；为了应对激增的流量，防止服务被击垮，经常使用某种算法来对流量进行某种限流，以保证后端服务的正常运行。</p>\n<p>本文介绍 计数器、令牌桶算法和楼桶算法及它们之间的优缺点。</p>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"计数器\"   >\n          <a href=\"#计数器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Counter Counter</span><br><span class=\"line\">type Counter struct &#123;</span><br><span class=\"line\">\trate  int</span><br><span class=\"line\">\tbegin time.Time</span><br><span class=\"line\">\tcycle time.Duration</span><br><span class=\"line\">\tcount int</span><br><span class=\"line\">\tlock  sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Set Set</span><br><span class=\"line\">func (c *Counter) Set(r int, cycle time.Duration) &#123;</span><br><span class=\"line\">\tc.rate &#x3D; r</span><br><span class=\"line\">\tc.begin &#x3D; time.Now()</span><br><span class=\"line\">\tc.cycle &#x3D; cycle</span><br><span class=\"line\">\tc.count &#x3D; 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Reset Reset</span><br><span class=\"line\">func (c *Counter) Reset(t time.Time) &#123;</span><br><span class=\"line\">\tc.begin &#x3D; t</span><br><span class=\"line\">\tc.count &#x3D; 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Allow Allow</span><br><span class=\"line\">func (c *Counter) Allow() bool &#123;</span><br><span class=\"line\">\tc.lock.Lock()</span><br><span class=\"line\">\tdefer c.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif c.count &#x3D;&#x3D; c.rate &#123;</span><br><span class=\"line\">\t\tnow :&#x3D; time.Now()</span><br><span class=\"line\">\t\tif now.Sub(c.begin) &gt;&#x3D; c.cycle &#123;</span><br><span class=\"line\">\t\t\tc.Reset(now)</span><br><span class=\"line\">\t\t\treturn true</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn false</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tc.count++</span><br><span class=\"line\">\t\treturn true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tvar wg sync.WaitGroup</span><br><span class=\"line\">\tlr :&#x3D; new(Counter)</span><br><span class=\"line\">\tlr.Set(3, time.Second)</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(1)</span><br><span class=\"line\">\t\tlog.Println(&quot;创建请求:&quot;, i)</span><br><span class=\"line\">\t\tgo func(i int) &#123;</span><br><span class=\"line\">\t\t\tif lr.Allow() &#123;</span><br><span class=\"line\">\t\t\t\tlog.Println(&quot;request allw: &quot;, i)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t\ttime.Sleep(200 * time.Millisecond)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题，我们看下图：<br><img src=\"/images/golang/limit/counter.png\" alt=\"counter\"><br>从上图中我们可以看到，假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。</p>\n\n        <h2 id=\"令牌桶算法\"   >\n          <a href=\"#令牌桶算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h2>\n      <p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p>\n<p><img src=\"/images/golang/limit/token-bucket.png\" alt=\"token-bucket\"></p>\n<ul>\n<li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li>\n<li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>\n<li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li>\n<li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>\n</ul>\n<p>官方实现：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pkg.go.dev/golang.org/x/time/rate\" >https://pkg.go.dev/golang.org/x/time/rate</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"通过-time-rate-包实现\"   >\n          <a href=\"#通过-time-rate-包实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#通过-time-rate-包实现\" class=\"headerlink\" title=\"通过 time/rate 包实现\"></a>通过 time/rate 包实现</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 构建限流对象</span><br><span class=\"line\">&#x2F;&#x2F; NewLimiter returns a new Limiter that allows events up to rate r and permits</span><br><span class=\"line\">&#x2F;&#x2F; bursts of at most b tokens.</span><br><span class=\"line\">func NewLimiter(r Limit, b int) *Limiter &#123;</span><br><span class=\"line\">    return &amp;Limiter&#123;</span><br><span class=\"line\">        limit: r,</span><br><span class=\"line\">        burst: b,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Allow/AllowN 判断是否允许通过</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Allow is shorthand for AllowN(time.Now(), 1).</span><br><span class=\"line\">func (lim *Limiter) Allow() bool &#123;</span><br><span class=\"line\">    return lim.AllowN(time.Now(), 1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; AllowN reports whether n events may happen at time now.</span><br><span class=\"line\">&#x2F;&#x2F; Use this method if you intend to drop &#x2F; skip events that exceed the rate limit.</span><br><span class=\"line\">&#x2F;&#x2F; Otherwise use Reserve or Wait.</span><br><span class=\"line\">func (lim *Limiter) AllowN(now time.Time, n int) bool &#123;</span><br><span class=\"line\">    return lim.reserveN(now, n, 0).ok</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>具体细节，请看官方实现。</p>\n\n        <h3 id=\"自己手动实现\"   >\n          <a href=\"#自己手动实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自己手动实现\" class=\"headerlink\" title=\"自己手动实现\"></a>自己手动实现</h3>\n      <p>demo示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;math&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type tokenBucket struct &#123;</span><br><span class=\"line\">\trate     int64 &#x2F;&#x2F; 速率</span><br><span class=\"line\">\tcapacity int64 &#x2F;&#x2F; 桶容量</span><br><span class=\"line\">\ttokens   int64 &#x2F;&#x2F; 桶内token 个数</span><br><span class=\"line\">\tlastTime time.Time</span><br><span class=\"line\">\tlock sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *tokenBucket) allow() bool &#123;</span><br><span class=\"line\">\tt.lock.Lock()</span><br><span class=\"line\">\tdefer t.lock.Unlock()</span><br><span class=\"line\">\tnow :&#x3D; time.Now()</span><br><span class=\"line\">\tt.tokens &#x3D; t.tokens + int64(now.Sub(t.lastTime).Seconds() * float64(t.rate))</span><br><span class=\"line\">\tt.tokens &#x3D; int64(math.Min(float64(t.tokens), float64(t.capacity)))</span><br><span class=\"line\">\tif t.tokens &gt; 0 &#123;</span><br><span class=\"line\">\t\tt.lastTime &#x3D; now</span><br><span class=\"line\">\t\tt.tokens--</span><br><span class=\"line\">\t\treturn true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewTokenBucket(r, c int64) *tokenBucket &#123;</span><br><span class=\"line\">\treturn &amp;tokenBucket&#123;</span><br><span class=\"line\">\t\trate:     r,</span><br><span class=\"line\">\t\tcapacity: c,</span><br><span class=\"line\">\t\ttokens:   0,</span><br><span class=\"line\">\t\tlastTime: time.Now(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>测试，此时每5个请求，一个请求成功</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tt :&#x3D; NewTokenBucket(2, 5)</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class=\"line\">\t\ttime.Sleep(time.Millisecond * 100)</span><br><span class=\"line\">\t\tif ok :&#x3D; t.allow(); ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;request allow!&quot;)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;request deny!&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request allow!</span><br><span class=\"line\">...</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"漏桶算法\"   >\n          <a href=\"#漏桶算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h2>\n      <p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：</p>\n<ul>\n<li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li>\n<li>如果桶是空的，则不需流出水滴。</li>\n<li>可以以任意速率流入水滴到漏桶。</li>\n<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li>\n</ul>\n<p>leaky-bucket rate limit algorithm:<br><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pkg.go.dev/go.uber.org/ratelimit\" >https://pkg.go.dev/go.uber.org/ratelimit</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"uber-ratelimit-官方实现\"   >\n          <a href=\"#uber-ratelimit-官方实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#uber-ratelimit-官方实现\" class=\"headerlink\" title=\"uber ratelimit 官方实现\"></a>uber ratelimit 官方实现</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&quot;go.uber.org&#x2F;ratelimit&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    rl :&#x3D; ratelimit.New(100) &#x2F;&#x2F; per second</span><br><span class=\"line\"></span><br><span class=\"line\">    prev :&#x3D; time.Now()</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 此处会被阻塞，直到请求允许通过</span><br><span class=\"line\">        &#x2F;&#x2F; Take should block to make sure that the RPS is met.</span><br><span class=\"line\">        now :&#x3D; rl.Take()</span><br><span class=\"line\">        fmt.Println(i, now.Sub(prev))</span><br><span class=\"line\">        prev &#x3D; now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Output:</span><br><span class=\"line\">    &#x2F;&#x2F; 0 0</span><br><span class=\"line\">    &#x2F;&#x2F; 1 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 2 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 3 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 4 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 5 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 6 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 7 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 8 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 9 10ms</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"自己实现\"   >\n          <a href=\"#自己实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自己实现\" class=\"headerlink\" title=\"自己实现\"></a>自己实现</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;math&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type LeakBucket struct &#123;</span><br><span class=\"line\">\trate       float64 &#x2F;&#x2F; 固定每秒出水率</span><br><span class=\"line\">\tcapacity   float64 &#x2F;&#x2F; 桶容量</span><br><span class=\"line\">\twater      float64 &#x2F;&#x2F; 桶中当前水量</span><br><span class=\"line\">\tlastLeakMs int64   &#x2F;&#x2F; 上次漏水时间戳</span><br><span class=\"line\">\tlock       sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (l *LeakBucket) Allow() bool &#123;</span><br><span class=\"line\">\tl.lock.Lock()</span><br><span class=\"line\">\tdefer l.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tnow :&#x3D; time.Now().UnixNano() &#x2F; 1e6</span><br><span class=\"line\">\teclipse :&#x3D; float64(now-l.lastLeakMs) * l.rate &#x2F; 1000</span><br><span class=\"line\">\tl.water &#x3D; l.water - eclipse</span><br><span class=\"line\">\tl.water &#x3D; math.Max(0, l.water)</span><br><span class=\"line\">\tif (l.water + 1) &lt; l.capacity &#123;</span><br><span class=\"line\">\t\tl.lastLeakMs &#x3D; now</span><br><span class=\"line\">\t\tl.water++</span><br><span class=\"line\">\t\treturn true</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func newBucket(r float64, c float64) *LeakBucket &#123;</span><br><span class=\"line\">\treturn &amp;LeakBucket&#123;</span><br><span class=\"line\">\t\trate:       r,</span><br><span class=\"line\">\t\tcapacity:   c,</span><br><span class=\"line\">\t\twater:      0,</span><br><span class=\"line\">\t\tlastLeakMs: time.Now().UnixNano() &#x2F; 1e6,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>计数器<br>漏桶算法 流出的速率是固定的，与令牌桶算法不同的是，令牌桶算法是放入的速率固定，取出的速率不固定，所以令牌桶算法支持流量的爆发。</p>\n","categories":["golang"],"tags":["golang","limiter"]},{"title":"rpc的核心原理-rpc的通信流程","url":"/2021/06/02/rpc%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-rpc%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/","content":"<p>RPC 是解决分布式系统通信问题的一大利器。</p>\n<p>分布式系统中的网络通信一般都会采用四层的 TCP 协议或七层的 HTTP 协议，前者占大多数，这主要得益于 TCP 协议的稳定性和高效性。网络通信说起来简单，但实际上是一个非常复杂的过程，这个过程主要包括：对端节点的查找、网络连接的建立、传输数据的编码解码以及网络连接的管理等等，每一项都很复杂。</p>\n<a id=\"more\"></a>\n\n<p>而 RPC 对网络通信的整个过程做了完整包装，在搭建分布式系统时，它会使网络通信逻辑的开发变得更加简单，同时也会让网络通信变得更加安全可靠。</p>\n\n        <h3 id=\"什么是RPC\"   >\n          <a href=\"#什么是RPC\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC?\"></a>什么是RPC?</h3>\n      <p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单从字面上来看，是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序，就可以称之为 RPC 调用了？显然并不够。</p>\n<p>RPC 是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。</p>\n<p>RPC 的作用就是体现在两个方面：</p>\n<ul>\n<li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li>\n<li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</li>\n</ul>\n\n        <h3 id=\"RPC的通信流程\"   >\n          <a href=\"#RPC的通信流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RPC的通信流程\" class=\"headerlink\" title=\"RPC的通信流程\"></a>RPC的通信流程</h3>\n      <p>一个完整的 RPC 会涉及到哪些步骤呢？</p>\n<p>RPC 是一个远程调用，需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。</p>\n<p>调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方从 TCP 通道里面收到二进制数据，那如何知道一个请求的数据到哪里结束，是一个什么类型的请求呢？这里就需要用到相关协议，而协议的作用就是做相关规定和约束。</p>\n<p>大多数的协议会分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。</p>\n<p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作“反序列化”。</p>\n<p>服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p>\n\n        <h3 id=\"完整的RPC通信流程\"   >\n          <a href=\"#完整的RPC通信流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#完整的RPC通信流程\" class=\"headerlink\" title=\"完整的RPC通信流程\"></a>完整的RPC通信流程</h3>\n      <p>如Spring的AOP技术，其核心是采用动态代理的技术，通过字节码增强对方法进行拦截增强，以便于增加需要的额外处理逻辑。其实这个技术也可以应用到 RPC 场景来解决我们刚才面临的问题。</p>\n<p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。</p>\n<p><img src=\"/images/golang/rpc/rpc-call-procedure.jpg\" alt=\"rpc_procedure\"></p>\n\n        <h3 id=\"RPC在架构中的位置\"   >\n          <a href=\"#RPC在架构中的位置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RPC在架构中的位置\" class=\"headerlink\" title=\"RPC在架构中的位置\"></a>RPC在架构中的位置</h3>\n      <p>如刚才所讲，RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从“单体”演进成“微服务化”，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是“经络”一样的存在。</p>\n<p>RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。</p>\n<p>利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p>\n\n        <h3 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n      <p>RPC 就是提供一种透明调用机制，让使用者不必显式地区分本地调用和远程调用。RPC 虽然可以帮助开发者屏蔽远程调用跟本地调用的区别，但毕竟涉及到远程网络通信，所以这里还是有很多使用上的区别，比如：</p>\n<ul>\n<li>调用过程中超时了怎么处理业务？</li>\n<li>什么场景下最适合使用 RPC？</li>\n<li>什么时候才需要考虑开启压缩？</li>\n</ul>\n","categories":["RPC"],"tags":["rpc"]},{"title":"透视http协议-破冰篇","url":"/2021/06/05/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE-%E7%A0%B4%E5%86%B0%E7%AF%87/","content":"\n        <h2 id=\"HTTP的前世今生\"   >\n          <a href=\"#HTTP的前世今生\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP的前世今生\" class=\"headerlink\" title=\"HTTP的前世今生\"></a>HTTP的前世今生</h2>\n      <p>HTTP 协议是怎么来的？它最开始是什么样子的？又是如何一步一步发展到今天，几乎“统治”了整个互联网世界的呢？</p>\n\n        <h3 id=\"史前时期\"   >\n          <a href=\"#史前时期\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#史前时期\" class=\"headerlink\" title=\"史前时期\"></a>史前时期</h3>\n      <p>20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。</p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"创世纪\"   >\n          <a href=\"#创世纪\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创世纪\" class=\"headerlink\" title=\"创世纪\"></a>创世纪</h3>\n      <p>1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。</p>\n<ol>\n<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>\n<li>HTML：即超文本标记语言，描述超文本文档；</li>\n<li>HTTP：即超文本传输协议，用来传输超文本。</li>\n</ol>\n<p>基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。</p>\n\n        <h3 id=\"HTTP-0-9\"   >\n          <a href=\"#HTTP-0-9\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h3>\n      <p>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p>\n<p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。</p>\n\n        <h3 id=\"HTTP-1-0\"   >\n          <a href=\"#HTTP-1-0\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h3>\n      <p>1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。</p>\n<p>同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。</p>\n<p>更的多的人开始使用互联网,促进了 HTTP 的发展。于是在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</p>\n<ol>\n<li>增加了 HEAD、POST 等新方法；</li>\n<li>增加了响应状态码，标记可能的错误原因；</li>\n<li>引入了协议版本号概念；</li>\n<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>\n<li>传输的数据不再仅限于文本。</li>\n</ol>\n\n        <h3 id=\"HTTP-1-1\"   >\n          <a href=\"#HTTP-1-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h3>\n      <p>1999 年，HTTP/1.1 发布了 RFC 文档,编号为 2616。HTTP/1.1 是对 HTTP/1.0 的小幅度修正，它是一个“正式的标准”，而不是一份可有可无的“参考文档”。意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p>\n<p>HTTP/1.1 主要的变更点有：</p>\n<ol>\n<li>增加了 PUT、DELETE 等新的方法；</li>\n<li>增加了缓存管理和控制；明确了连接管理，允许持久连接；</li>\n<li>允许响应数据分块（chunked），利于传输大文件；</li>\n<li>强制要求 Host 头，让互联网主机托管成为可能。</li>\n</ol>\n\n        <h3 id=\"HTTP-2\"   >\n          <a href=\"#HTTP-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h3>\n      <p>Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</p>\n<p>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</p>\n<ol>\n<li>二进制协议，不再是纯文本；</li>\n<li>可发起多个请求，废弃了 1.1 里的管道；</li>\n<li>使用专用算法压缩头部，减少数据传输量；</li>\n<li>允许服务器主动向客户端推送数据；增强了安全性，“事实上”要求加密通信。</li>\n</ol>\n\n        <h3 id=\"HTTP-3\"   >\n          <a href=\"#HTTP-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-3\" class=\"headerlink\" title=\"HTTP/3\"></a>HTTP/3</h3>\n      <p>Google 发明的另一个个新的协议 QUIC （Quick UDP Internet Connection）,2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段。</p>\n\n        <h3 id=\"小结\"   >\n          <a href=\"#小结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；</li>\n<li>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</li>\n<li>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</li>\n<li>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</li>\n<li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</li>\n<li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</li>\n</ol>\n\n        <h2 id=\"HTTP是什么？HTTP又不是什么？\"   >\n          <a href=\"#HTTP是什么？HTTP又不是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP是什么？HTTP又不是什么？\" class=\"headerlink\" title=\"HTTP是什么？HTTP又不是什么？\"></a>HTTP是什么？HTTP又不是什么？</h2>\n      <p>HTTP 就是超文本传输协议，也就是 HyperText Transfer Protocol。</p>\n\n        <h3 id=\"HTTP-是什么\"   >\n          <a href=\"#HTTP-是什么\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-是什么\" class=\"headerlink\" title=\"HTTP 是什么\"></a>HTTP 是什么</h3>\n      <p>“超文本传输协议”，分别是：“超文本”“传输”和“协议”</p>\n<p><strong>HTTP 是一个协议</strong></p>\n<p>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</p>\n<p><strong>HTTP 是一个“传输协议”</strong></p>\n<p>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</p>\n<p><strong>超文本</strong></p>\n<p>所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。</p>\n<p><strong>HTTP（超文本传输协议）的定义</strong><br>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>\n\n        <h3 id=\"HTTP-不是什么？\"   >\n          <a href=\"#HTTP-不是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-不是什么？\" class=\"headerlink\" title=\"HTTP 不是什么？\"></a>HTTP 不是什么？</h3>\n      <p>HTTP 是一个协议，不存在“单独的实体”。它不是浏览器、手机 APP 那样的应用程序，也不是 Windows、Linux 那样的操作系统，更不是 Apache、Nginx、Tomcat 那样的 Web 服务器。</p>\n<ul>\n<li>HTTP 不是互联网。</li>\n<li>HTTP 不是编程语言</li>\n<li>HTTP 不是 HTML</li>\n<li>HTTP 不是一个孤立的协议</li>\n</ul>\n<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>\n\n        <h3 id=\"小结-1\"   >\n          <a href=\"#小结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ul>\n<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>\n<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。</li>\n<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>\n<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>\n</ul>\n\n        <h2 id=\"HTTP世界全览-上\"   >\n          <a href=\"#HTTP世界全览-上\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP世界全览-上\" class=\"headerlink\" title=\"HTTP世界全览 - 上\"></a>HTTP世界全览 - 上</h2>\n      <p>介绍HTTP 相关的各种概念和角色，清楚它们在链路中的位置和作用，以及发起一个 HTTP 请求会有哪些角色参与，会如何影响请求的处理。</p>\n\n        <h3 id=\"网络世界\"   >\n          <a href=\"#网络世界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网络世界\" class=\"headerlink\" title=\"网络世界\"></a>网络世界</h3>\n      <p>互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p>\n<p>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</p>\n\n        <h3 id=\"浏览器\"   >\n          <a href=\"#浏览器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3>\n      <p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，浏览器的正式名字叫“Web Browser”，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。</p>\n<p>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。例如，HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，还有开发者工具用来调试网页。</p>\n<p>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。通常都简单地称之为“客户端”。</p>\n\n        <h3 id=\"Web-服务器\"   >\n          <a href=\"#Web-服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Web-服务器\" class=\"headerlink\" title=\"Web 服务器\"></a>Web 服务器</h3>\n      <p>协议另一端的应答方（响应方）就是服务器，Web Server。</p>\n<p>Web 服务器 有两个层面的含义：硬件和软件。</p>\n<p><strong>硬件</strong>含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。<br><strong>软件</strong>是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。</p>\n\n        <h3 id=\"CDN\"   >\n          <a href=\"#CDN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3>\n      <p>浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</p>\n<p>CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p>\n<p>CDN 可以缓存源站的数据，可以找到离用户最近的节点，大幅度缩短响应时间。</p>\n\n        <h3 id=\"HTML-WebService-WAF\"   >\n          <a href=\"#HTML-WebService-WAF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTML-WebService-WAF\" class=\"headerlink\" title=\"HTML/WebService/WAF\"></a>HTML/WebService/WAF</h3>\n      <p>HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</p>\n<p>Web Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。</p>\n<p>WAF 是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。</p>\n<p>WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p>\n<ol>\n<li>互联网上绝大部分资源都使用 HTTP 协议传输；</li>\n<li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li>\n<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>\n<li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>\n<li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li>\n</ol>\n\n        <h2 id=\"HTTP世界全览-下\"   >\n          <a href=\"#HTTP世界全览-下\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP世界全览-下\" class=\"headerlink\" title=\"HTTP世界全览 - 下\"></a>HTTP世界全览 - 下</h2>\n      <p>与HTTP 相关的 TCP/IP、DNS、URI、HTTPS 等相关协议介绍。</p>\n\n        <h3 id=\"TCP-IP\"   >\n          <a href=\"#TCP-IP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3>\n      <p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>\n<p>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。</p>\n<p>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。</p>\n<p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。但互联网的快速发展让地址的分配管理很快就耗尽了，所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个。</p>\n<p>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</p>\n<p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p>\n<p>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。</p>\n\n        <h3 id=\"DNS\"   >\n          <a href=\"#DNS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3>\n      <p>域名系统（Domain Name System），为了将一串无意义的数字通过一串有意义的字符表示更好的记忆。</p>\n<p>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</p>\n<p>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等。</p>\n<p>想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是“域名解析”。</p>\n<p>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。</p>\n<p>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p>\n\n        <h3 id=\"URI-URL\"   >\n          <a href=\"#URI-URL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#URI-URL\" class=\"headerlink\" title=\"URI/URL\"></a>URI/URL</h3>\n      <p>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>\n<p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html</span><br></pre></td></tr></table></div></figure>\n<p>可以看到，URI 主要有三个基本的部分构成：</p>\n<ol>\n<li>协议名：即访问该资源应当使用的协议，在这里是“http”；</li>\n<li>主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</li>\n<li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</li>\n</ol>\n\n        <h3 id=\"HTTPS\"   >\n          <a href=\"#HTTPS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3>\n      <p>HTTPS 它的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。</p>\n<p>这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”。</p>\n<p>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</p>\n<p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>\n<p>浏览器地址栏，如果有一个小锁头标志，那就表明网站启用了安全的 HTTPS 协议，而 URI 里的协议名，也从“http”变成了“https”。</p>\n\n        <h3 id=\"代理\"   >\n          <a href=\"#代理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3>\n      <p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</p>\n<p>代理有很多的种类，常见的有：</p>\n<ol>\n<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>\n<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>\n<li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li>\n<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>\n</ol>\n<p>CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>\n<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多事情，比如：</p>\n<ol>\n<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>\n<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>\n<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>\n<li>数据处理：提供压缩、加密等额外的功能。</li>\n</ol>\n<p>关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订。</p>\n\n        <h3 id=\"小结-2\"   >\n          <a href=\"#小结-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>\n<li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</li>\n<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>\n<li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；</li>\n<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>\n</ol>\n\n        <h3 id=\"小贴士\"   >\n          <a href=\"#小贴士\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小贴士\" class=\"headerlink\" title=\"小贴士\"></a>小贴士</h3>\n      <ul>\n<li>IP 协议曾经有v1,v2, v3等早期版本，但因为不够完善而没有对外发布。而v5 则是仅用于实验室内部研究，从未公开，所以我们看到的只有v4和v6两个版本。</li>\n<li>2011年2月互联网组织ICANN 正式宣布IPV4 地址被”用尽”</li>\n<li>如果使用 UNIX/Linux 操作系统，HTTP可以运行在本机的 UNIX Domain Socket 上，它也是一种进程间通信机制，但也可以满足HTTP 对下层对可靠传输要求，所以就成了”HTTP over UNIX Domain Soocket”。</li>\n</ul>\n\n        <h2 id=\"常说的“四层”和“七层”到底是什么？\"   >\n          <a href=\"#常说的“四层”和“七层”到底是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常说的“四层”和“七层”到底是什么？\" class=\"headerlink\" title=\"常说的“四层”和“七层”到底是什么？\"></a>常说的“四层”和“七层”到底是什么？</h2>\n      <p>TCP/IP 协议，它是 HTTP 协议的下层协议，负责具体的数据传输工作。强调了 TCP/IP 协议是一个 <strong>“有层次的协议栈”</strong>。</p>\n\n        <h3 id=\"TCP-IP-网络分层模型\"   >\n          <a href=\"#TCP-IP-网络分层模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP-网络分层模型\" class=\"headerlink\" title=\"TCP/IP 网络分层模型\"></a>TCP/IP 网络分层模型</h3>\n      <p>TCP/IP 创造性地提出了“分层”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。</p>\n<p>如图所示：</p>\n<img src=\"/images/http/tcp-layer.png\" art=\"tcp_layer\" width=\"400px\">\n\n<p>TCP/IP 协议总共有四层，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。</p>\n<p>从下往上看：</p>\n<p>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>\n<p>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>\n<p>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>\n<p>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</p>\n<p>协议栈的第四层叫“应用层”（application layer），有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有 HTTP。</p>\n<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>\n\n        <h3 id=\"OSI-网络分层模型\"   >\n          <a href=\"#OSI-网络分层模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSI-网络分层模型\" class=\"headerlink\" title=\"OSI 网络分层模型\"></a>OSI 网络分层模型</h3>\n      <p>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。</p>\n<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>\n<img src=\"/images/http/osi-layer.png\" art=\"osi_layer\" width=\"400px\">\n\n<ol>\n<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>\n<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>\n<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>\n<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>\n<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>\n<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>\n<li>第七层：应用层，面向具体的应用传输数据。</li>\n</ol>\n\n        <h3 id=\"两个分层模型的映射关系\"   >\n          <a href=\"#两个分层模型的映射关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两个分层模型的映射关系\" class=\"headerlink\" title=\"两个分层模型的映射关系\"></a>两个分层模型的映射关系</h3>\n      <img src=\"/images/http/tcp-osi-map.png\" art=\"tcp-osi-map\" width=\"400px\">\n\n<ol>\n<li>第一层：物理层，TCP/IP 里无对应；</li>\n<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>\n<li>第三层：网络层，对应 TCP/IP 的网际层；</li>\n<li>第四层：传输层，对应 TCP/IP 的传输层；</li>\n<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>\n</ol>\n<p>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义</p>\n<p>“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>\n<p>“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>\n\n        <h3 id=\"TCP-IP-协议栈的工作方式\"   >\n          <a href=\"#TCP-IP-协议栈的工作方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP-协议栈的工作方式\" class=\"headerlink\" title=\"TCP/IP 协议栈的工作方式\"></a>TCP/IP 协议栈的工作方式</h3>\n      <p>发送数据的过程：</p>\n<ol>\n<li>在应用层，HTTP 协议为它加一个 HTTP 专用附加数据</li>\n<li>在 TCP 层给数据再次打包，加上了 TCP 头</li>\n<li>IP 层为TCP 数据包加上了 IP 头</li>\n<li>MAC 层对TCP 数据包加上MAC 头</li>\n<li>之后经过网络传输到达重点</li>\n<li>目标服务经过拆包 去掉 mac头 ip头和TCP头 获取到真正数据</li>\n</ol>\n<p>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</p>\n<p>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</p>\n\n        <h3 id=\"小结-3\"   >\n          <a href=\"#小结-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；</li>\n<li>OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；</li>\n<li>OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；</li>\n<li>日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；</li>\n<li>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</li>\n</ol>\n<p>辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：</p>\n<ul>\n<li>凡是由操作系统负责处理的就是四层或四层以下</li>\n<li>凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</li>\n</ul>\n\n        <h3 id=\"小贴士-1\"   >\n          <a href=\"#小贴士-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小贴士-1\" class=\"headerlink\" title=\"小贴士\"></a>小贴士</h3>\n      <ol>\n<li>MAC地址（Media Access Control Address）也称为局域网地址，可以唯一的标识一个网卡，也就同时标识了此网卡的设备。</li>\n<li>在 TCP/IP 协议栈之外，还有一些协议位于OSI 五层和六层的，例如：UNIX 域套接字就可以认为是在五层。</li>\n</ol>\n\n        <h2 id=\"域名里有哪些门道？\"   >\n          <a href=\"#域名里有哪些门道？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名里有哪些门道？\" class=\"headerlink\" title=\"域名里有哪些门道？\"></a>域名里有哪些门道？</h2>\n      \n        <h3 id=\"域名的形式\"   >\n          <a href=\"#域名的形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名的形式\" class=\"headerlink\" title=\"域名的形式\"></a>域名的形式</h3>\n      <p>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</p>\n<p>最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务。</p>\n<p>如： time.geekbang.org 这里的“org”就是顶级域名，“geekbang”是二级域名，“time”则是主机名。</p>\n<p>域名不仅能够代替 IP 地址，还有许多其他的用途</p>\n<p>在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;                       #监听80端口</span><br><span class=\"line\">    server_name  time.geekbang.org;  #主机名是time.geekbang.org</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"域名的解析\"   >\n          <a href=\"#域名的解析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名的解析\" class=\"headerlink\" title=\"域名的解析\"></a>域名的解析</h3>\n      <p>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。</p>\n<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>\n<ol>\n<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>\n<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>\n<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.apple.com/\" >www.apple.com</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> 的 IP 地址。</li>\n</ol>\n<img src=\"/images/http/dns.png\" art=\"dns\" width=\"400px\">\n\n<p>目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。</p>\n<p>例如，你要访问“<a href=\"http://www.apple.com”，就要进行下面的三次查询：\">www.apple.com”，就要进行下面的三次查询：</a></p>\n<ol>\n<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>\n<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>\n<li>最后访问“apple.com”域名服务器，就得到了“<span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.apple.com”的地址./\" >www.apple.com”的地址。</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n<p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</p>\n<p>许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>\n<p>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>\n<p>其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“<span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.apple.com”,那么下一次在浏览器里再输入这个网址的时候就不会再跑到/\" >www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>\n<p>另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\\WINDOWS\\system32\\drivers\\etc\\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p>\n<p>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力。</p>\n<p>如图：完整地表示了现在的 DNS 架构。</p>\n<img src=\"/images/http/dns-now.png\" art=\"dns-now\" width=\"400px\">\n\n<p>在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">resolver 8.8.8.8 valid&#x3D;30s;  #指定Google的DNS，缓存30秒</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"域名的“新玩法”\"   >\n          <a href=\"#域名的“新玩法”\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名的“新玩法”\" class=\"headerlink\" title=\"域名的“新玩法”\"></a>域名的“新玩法”</h3>\n      <p>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</p>\n<p>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名。</p>\n<p>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。</p>\n<p>这种“玩法”也有两种方式，两种方式可以混用。</p>\n<p>第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</p>\n<p>第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</p>\n<p><strong>恶意的“玩法”</strong></p>\n<ul>\n<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>\n<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>\n</ul>\n\n        <h3 id=\"小结-4\"   >\n          <a href=\"#小结-4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；</li>\n<li>DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；</li>\n<li>DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；</li>\n<li>使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。</li>\n</ol>\n\n        <h3 id=\"小贴士-2\"   >\n          <a href=\"#小贴士-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小贴士-2\" class=\"headerlink\" title=\"小贴士\"></a>小贴士</h3>\n      <p>域名的总长度限制在253个字符以内，而每一级域名长度不能超过63个字符。</p>\n","categories":["http"],"tags":["http","tcp/ip"]},{"title":"kratos内置protobuf类型使用","url":"/2021/06/08/kratos%E5%86%85%E7%BD%AEprotobuf%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/","content":"<p>在使用 kratos 开发过程中，使用protocal buffers 定义传参类型时，经常会遇到复杂场景及一些特殊情况，本文介绍protocal buffers内置数据类型的使用场景及使用使用示例。由于个人水平有限，如有不当之处还请指正。</p>\n\n        <h2 id=\"空请求-empty-类型\"   >\n          <a href=\"#空请求-empty-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#空请求-empty-类型\" class=\"headerlink\" title=\"空请求 empty 类型\"></a>空请求 empty 类型</h2>\n      <p>适用无传参或返回的message 类型，但通常不建议使用，为了 更好但向后兼容，通常定义一个空但message。</p>\n<p>需要导入 google/protobuf/empty.proto 包。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">rpc SayEmpty (google.protobuf.Empty) returns (HelloReply)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      get: &quot;&#x2F;helloworld&#x2F;&#123;name&#125;&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></div></figure>\n<p>service 层使用方法，则需要导入 emptypb  包</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google.golang.org&#x2F;protobuf&#x2F;types&#x2F;known&#x2F;emptypb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *GreeterService) SayEmpty(ctx context.Context, _ *emptypb.Empty)  (*v1.HelloReply, error) &#123;</span><br><span class=\"line\">\treturn &amp;v1.HelloReply&#123;Message: &quot;Hello empty&quot;&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"wrappers-类型\"   >\n          <a href=\"#wrappers-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#wrappers-类型\" class=\"headerlink\" title=\"wrappers 类型\"></a>wrappers 类型</h2>\n      <p>用于区分参数为空及默认值场景。</p>\n<p>protocal buffers  定义的message 中，参数值默认为类型的默认值，即：bool 类型默认为 false, int32，int64 默认为 0，string 默认为空字符串等等。</p>\n<p>如何区分本身是默认值还是传参数为空呢？这里就需要用到wrappers包的相关类型。</p>\n<p>proto 定义：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;wrappers.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloIsDefaultRequest &#123;</span><br><span class=\"line\">  string name &#x3D; 1;</span><br><span class=\"line\">  google.protobuf.Int32Value age &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>service 使用：</p>\n<p>可通过值是否为 nil 来判断是否为默认值还是传参为类型的0值。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) IsDefault(ctx context.Context, in *v1.HelloIsDefaultRequest) (*v1.HelloDefaultReply, error)  &#123;</span><br><span class=\"line\">\tvar age int32</span><br><span class=\"line\">\tif in.GetAge() !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tage &#x3D; in.GetAge().GetValue()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn &amp;v1.HelloDefaultReply&#123;</span><br><span class=\"line\">\t\tName: in.GetName(),</span><br><span class=\"line\">\t\tAge:  age,</span><br><span class=\"line\">\t&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"FieldMask-类型\"   >\n          <a href=\"#FieldMask-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#FieldMask-类型\" class=\"headerlink\" title=\"FieldMask 类型\"></a>FieldMask 类型</h2>\n      <p>个人在使用过程中，主要用于更新方法，通过传参FieldMask 来控制更新字段</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;field_mask.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc FiledMask (HelloFieldMaskRequest) returns (HelloFieldMaskResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;fieldMask&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloFieldMaskRequest &#123;</span><br><span class=\"line\">  int32 task_id &#x3D; 1;</span><br><span class=\"line\">  bool is_delete &#x3D; 2;</span><br><span class=\"line\">  bool is_finished &#x3D; 3;</span><br><span class=\"line\">  google.protobuf.FieldMask field_mask &#x3D; 4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloFieldMaskResponse &#123;</span><br><span class=\"line\">  repeated string field_mask &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>service 接收示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) FiledMask(ctx context.Context, in *v1.HelloFieldMaskRequest) (*v1.HelloFieldMaskResponse, error)  &#123;</span><br><span class=\"line\">\ts.log.Infof(&quot;task_id &#x3D; %+v&quot;, in.GetTaskId())</span><br><span class=\"line\">\ts.log.Infof(&quot;is_finished &#x3D; %+v&quot;, in.GetIsFinished())</span><br><span class=\"line\">\ts.log.Infof(&quot;is_deleted &#x3D; %+v&quot;, in.GetIsDelete())</span><br><span class=\"line\">\treturn &amp;v1.HelloFieldMaskResponse&#123;</span><br><span class=\"line\">\t\tFieldMask: in.GetFieldMask().Paths,</span><br><span class=\"line\">\t&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>此时接收到到FieldMask 字段为slice 类型，可判断字段是否在slice 里做响应逻辑处理。</p>\n<p>请求示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;task_id&quot;:1, &quot;is_finished&quot;:true,&quot;field_mask&quot;:&quot;isFinished&quot;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;fieldMask</span><br></pre></td></tr></table></div></figure>\n<p>注意 传参为camelCase 类型，即 生成到pb文件里，tag为 protobuf json定义：isFinished, isDelete</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">type HelloFieldMaskRequest struct &#123;</span><br><span class=\"line\">\tstate         protoimpl.MessageState</span><br><span class=\"line\">\tsizeCache     protoimpl.SizeCache</span><br><span class=\"line\">\tunknownFields protoimpl.UnknownFields</span><br><span class=\"line\"></span><br><span class=\"line\">\tTaskId     int32                  &#96;protobuf:&quot;varint,1,opt,name&#x3D;task_id,json&#x3D;taskId,proto3&quot; json:&quot;task_id,omitempty&quot;&#96;</span><br><span class=\"line\">\tIsDelete   bool                   &#96;protobuf:&quot;varint,2,opt,name&#x3D;is_delete,json&#x3D;isDelete,proto3&quot; json:&quot;is_delete,omitempty&quot;&#96;</span><br><span class=\"line\">\tIsFinished bool                   &#96;protobuf:&quot;varint,3,opt,name&#x3D;is_finished,json&#x3D;isFinished,proto3&quot; json:&quot;is_finished,omitempty&quot;&#96;</span><br><span class=\"line\">\tFieldMask  *fieldmaskpb.FieldMask &#96;protobuf:&quot;bytes,4,opt,name&#x3D;field_mask,json&#x3D;fieldMask,proto3&quot; json:&quot;field_mask,omitempty&quot;&#96;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Any-类型\"   >\n          <a href=\"#Any-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Any-类型\" class=\"headerlink\" title=\"Any 类型\"></a>Any 类型</h2>\n      <p>官方定义：</p>\n<blockquote>\n<p>The Any message type lets you use messages as embedded types without having their .proto definition. An Any contains an arbitrary serialized message as bytes, along with a URL that acts as a globally unique identifier for and resolves to that message’s type. To use the Any type, you need to import google/protobuf/any.proto.</p>\n</blockquote>\n<p>Any 消息类型允许您将消息用作嵌入类型，而无需它们的 .proto 定义。 Any 包含作为字节的任意序列化消息，以及充当全局唯一标识符并解析为该消息类型的 URL。 要使用 Any 类型，您需要导入 google/protobuf/any.proto。</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message ErrorStatus &#123;</span><br><span class=\"line\">  string message &#x3D; 1;</span><br><span class=\"line\">  repeated google.protobuf.Any details &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>给定消息类型的 URL 定义格式为：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">type.googleapis.com&#x2F;_packagename_._messagename_.</span><br></pre></td></tr></table></div></figure>\n<p>使用示例：proto 定义</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax &#x3D; &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package helloworld.v1;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc AnyTypes (HelloAnyTypesRequest) returns (HelloAnyTypesResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;any&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloAnyTypesRequest &#123;</span><br><span class=\"line\">  string topic &#x3D; 1;</span><br><span class=\"line\">  google.protobuf.Any desc &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message DescType &#123;</span><br><span class=\"line\">  string value &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloAnyTypesResponse &#123;</span><br><span class=\"line\">  string topic &#x3D; 1;</span><br><span class=\"line\">  string desc &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>service 使用示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) AnyTypes(ctx context.Context, in *v1.HelloAnyTypesRequest) (*v1.HelloAnyTypesResponse, error)  &#123;</span><br><span class=\"line\">\ts.log.Infof(&quot;topic &#x3D; %+v&quot;, in.GetTopic())</span><br><span class=\"line\">\ts.log.Infof(&quot;desc &#x3D; %s&quot;, in.GetDesc().GetValue())</span><br><span class=\"line\">\treturn &amp;v1.HelloAnyTypesResponse&#123;</span><br><span class=\"line\">\t\tTopic: in.GetTopic(),</span><br><span class=\"line\">\t\tDesc: string(in.GetDesc().GetValue()),</span><br><span class=\"line\">\t&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>请求示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;topic&quot;:&quot;this is any type&quot;, &quot;desc&quot;:&#123;&quot;@type&quot;:&quot;type.googleapis.com&#x2F;helloworld.v1.DescType&quot;, &quot;value&quot;:&quot;this is any type desc&quot;&#125;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;any</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>@type 为 type.googleapis.com/ + package name + message name</li>\n<li>value 为message 的字段定义</li>\n</ul>\n<p>** Timestamp 类型</p>\n<p>传递 ISO 时间对象，接收到之后，通过proto可以任意 转换时间对象方便处理：</p>\n<p>proto 定义：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax &#x3D; &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc Times (HelloTsRequest) returns (HelloTsResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;ts&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloTsRequest &#123;</span><br><span class=\"line\">  google.protobuf.Timestamp time_begin &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloTsResponse &#123;</span><br><span class=\"line\">  int64 timestamp &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>service 使用示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) Times(ctx context.Context, in *v1.HelloTsRequest) (*v1.HelloTsResponse, error)  &#123;</span><br><span class=\"line\">\ts.log.Infof(&quot;seconds &#x3D; %+v&quot;, in.GetTimeBegin().GetSeconds())</span><br><span class=\"line\">\ts.log.Infof(&quot;nano &#x3D; %s&quot;, in.GetTimeBegin().GetNanos())</span><br><span class=\"line\">\treturn &amp;v1.HelloTsResponse&#123;Timestamp: in.GetTimeBegin().GetSeconds()&#125;,nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>调用示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;time_begin&quot;:&quot;2021-06-08T15:15:30.069Z&quot;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;ts</span><br></pre></td></tr></table></div></figure>\n<p>注意传递的时间对象为UTC标准时间，否则转化获取到的时间戳不正确。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\" >javascript demo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"参考\"   >\n          <a href=\"#参考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developers.google.com/protocol-buffers/docs/proto3\" >https://developers.google.com/protocol-buffers/docs/proto3</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["golang"],"tags":["grpc","Protocol Buffers","kratos"]}]