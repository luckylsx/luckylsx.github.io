[{"title":"git 提交信息规范","url":"/2021/04/11/git-commit-message/","content":"\n        <h2 id=\"您可以遵循的Git-commit消息约定！\"   >\n          <a href=\"#您可以遵循的Git-commit消息约定！\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#您可以遵循的Git-commit消息约定！\" class=\"headerlink\" title=\"您可以遵循的Git commit消息约定！\"></a>您可以遵循的Git commit消息约定！</h2>\n      <p>典型的git commit消息像下面这样</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"“类型”必须是以下提到的以下内容之一！\"   >\n          <a href=\"#“类型”必须是以下提到的以下内容之一！\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“类型”必须是以下提到的以下内容之一！\" class=\"headerlink\" title=\"“类型”必须是以下提到的以下内容之一！\"></a>“类型”必须是以下提到的以下内容之一！</h3>\n      <a id=\"more\"></a>\n\n<ul>\n<li>build: 建立相关的更改（例如：与npm相关/添加外部依赖项）</li>\n<li>chore: 外部用户看不到的代码更改（例如：更改为.gitignore文件或.prettierrc文件）</li>\n<li>feat: 新特性</li>\n<li>fix: bug修复</li>\n<li>docs: 与文档相关的改变</li>\n<li>refactor: 既不修复错误也不添加功能的代码。 （例如：您可以在语义更改（例如重命名变量/函数名称）时使用此功能）</li>\n<li>perf: 可以提高性能的代码</li>\n<li>style: 有关样式的代码</li>\n<li>test: 添加新测试或对现有测试进行更改</li>\n<li>update: 更新</li>\n<li>upgrade: 升级</li>\n<li>sponsors: 赞助相关</li>\n</ul>\n\n        <h3 id=\"“scope”-是可选的\"   >\n          <a href=\"#“scope”-是可选的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“scope”-是可选的\" class=\"headerlink\" title=\"“scope” 是可选的\"></a>“scope” 是可选的</h3>\n      <ul>\n<li>scope 必须是名词，并且代表代码库部分的部分</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://karma-runner.github.io/1.0/dev/git-commit-msg.html\" >请参阅此链接以获取与scope相关的示例</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"“subject”\"   >\n          <a href=\"#“subject”\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#“subject”\" class=\"headerlink\" title=\"“subject”\"></a>“subject”</h3>\n      <ul>\n<li>使用命令式，现在时(如： 使用”add” 代替 “added” 或 “adds”)</li>\n<li>不要使用 “.” 结尾</li>\n<li>不要使用首字母大写方式</li>\n</ul>\n<p><strong><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/eslint/eslint/commits/master\" >请参阅此链接以获取更多实用的提交消息示例</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></strong></p>\n\n        <h3 id=\"References\"   >\n          <a href=\"#References\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#References\" class=\"headerlink\" title=\"References:\"></a>References:</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.conventionalcommits.org/en/v1.0.0/\" >https://www.conventionalcommits.org/en/v1.0.0/</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716\" >https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/fteem/git-semantic-commits\" >https://github.com/fteem/git-semantic-commits</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["mysql"],"tags":["git"]},{"title":"golang-gmp","url":"/2021/03/27/golang/","content":"<p>this is golang new test</p>\n","categories":["golang"]},{"title":"Hello World","url":"/2021/03/27/hello-world/","content":"<p>Welcome to <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/\" >Hexo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>! This is your very first post. Check <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/\" >documentation</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/troubleshooting.html\" >troubleshooting</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> or you can ask me on <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hexojs/hexo/issues\" >GitHub</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>.</p>\n\n        <h2 id=\"Quick-Start\"   >\n          <a href=\"#Quick-Start\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2>\n      \n        <h3 id=\"Create-a-new-post\"   >\n          <a href=\"#Create-a-new-post\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/writing.html\" >Writing</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"Run-server\"   >\n          <a href=\"#Run-server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/server.html\" >Server</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Generate-static-files\"   >\n          <a href=\"#Generate-static-files\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/generating.html\" >Generating</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Deploy-to-remote-sites\"   >\n          <a href=\"#Deploy-to-remote-sites\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/one-command-deployment.html\" >Deployment</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n"},{"title":"http vs https","url":"/2021/03/27/https/","content":"<p>Welcome to <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/\" >Hexo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>! This is your very first post. Check <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/\" >documentation</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/troubleshooting.html\" >troubleshooting</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> or you can ask me on <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hexojs/hexo/issues\" >GitHub</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>.</p>\n\n        <h2 id=\"Quick-Start\"   >\n          <a href=\"#Quick-Start\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2>\n      \n        <h3 id=\"Create-a-new-post\"   >\n          <a href=\"#Create-a-new-post\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/writing.html\" >Writing</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"Run-server\"   >\n          <a href=\"#Run-server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/server.html\" >Server</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Generate-static-files\"   >\n          <a href=\"#Generate-static-files\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/generating.html\" >Generating</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"Deploy-to-remote-sites\"   >\n          <a href=\"#Deploy-to-remote-sites\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3>\n      <figure class=\"highlight bash\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></div></figure>\n<p>More info: <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://hexo.io/docs/one-command-deployment.html\" >Deployment</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n"},{"title":"http 准则","url":"/2021/05/27/http%E5%87%86%E5%88%99/","content":"\n        <h2 id=\"HTTP-准则\"   >\n          <a href=\"#HTTP-准则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-准则\" class=\"headerlink\" title=\"HTTP 准则\"></a>HTTP 准则</h2>\n      <p>本文档介绍了 Google API 如何与不同的 HTTP 版本和实现结合使用。</p>\n\n        <h2 id=\"使用传输协议-HTTP\"   >\n          <a href=\"#使用传输协议-HTTP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用传输协议-HTTP\" class=\"headerlink\" title=\"使用传输协议 (HTTP/*)\"></a>使用传输协议 (HTTP/*)</h2>\n      <a id=\"more\"></a>\n\n<p>本部分介绍 Cloud API 可用于在客户端和服务器之间进行通信的支持的传输协议（通常是某个版本的 HTTP），以及我们为您建议的协议使用方式。我们将在下一部分详细介绍请求和响应的结构。</p>\n\n        <h3 id=\"HTTP-语义\"   >\n          <a href=\"#HTTP-语义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-语义\" class=\"headerlink\" title=\"HTTP 语义\"></a>HTTP 语义</h3>\n      <p>开发 API 客户端代码时，请遵循标准 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc7231\" >HTTP 协议语义</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。服务器端代理或 API 堆栈可能仅支持标准 HTTP 功能的子集，并且还可能支持其向后兼容的版本。</p>\n<p>需要由 API 的服务器端实现处理的 HTTP 协议语义由服务器堆栈控制。仅当这些功能明确记录为 API 规范（例如缓存支持）的一部分时，才能依赖此类语义。</p>\n\n        <h3 id=\"HTTP-版本\"   >\n          <a href=\"#HTTP-版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-版本\" class=\"headerlink\" title=\"HTTP 版本\"></a>HTTP 版本</h3>\n      <p>客户端可以使用客户端平台或其客户端网络允许或者与服务器端代理协商的任何 HTTP/* 协议。支持的协议包括 HTTP/1.0、HTTP/1.1、SPDY/*、HTTP/2 和 QUIC。</p>\n<p>某些 API 功能可能只有较新版本的 HTTP 协议（例如服务器推送和优先级）才支持；部分功能仅使用 HTTP/2（例如全双工流式传输）完全指定。如果您需要将这些功能中的任何功能作为 API 规范的一部分，请注意不同 HTTP 版本的限制。</p>\n<p>通常，为了提高性能和网络故障的恢复能力，建议使用 HTTP/2。</p>\n\n        <h3 id=\"渠道\"   >\n          <a href=\"#渠道\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#渠道\" class=\"headerlink\" title=\"渠道\"></a>渠道</h3>\n      <p>信道是指 L4 网络连接（TCP 或 UDP 套接字）。客户端应用不应该针对在运行时中如何使用信道来提供 HTTP 请求作出任何假设。在几乎所有情况下，信道都是由代表服务器进程的代理来终止。</p>\n<p>对于 HTTP/1.1 客户端，应始终重复使用 TCP 连接 (Connection: Keep-Alive)；为了获得更好的性能，HTTP 客户端库也可能会管理连接池。请不要通过相同的 TCP 连接传递请求。如需了解详情，请参阅 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/httpwg/wiki/wiki/TCP\" >HTTP 和 TCP</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。</p>\n<p>现代浏览器都使用 SPDY/*、HTTP/2 或 QUIC 进行通信，它们通过单个信道多路传输请求。除非服务器实现限制来自单个客户端的并发 HTTP 请求数 例如，针对单个源的 100 个 HTTP/2 信息流），否则传统的连接限制 (2-10) 永远不应该成为问题。</p>\n\n        <h3 id=\"HTTPS\"   >\n          <a href=\"#HTTPS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3>\n      <p>客户端可以通过 API 规范支持的 HTTPS 或 HTTP 访问 API。TLS 协商和 TLS 版本对客户端应用是透明的。默认情况下，Google API 仅接受 HTTPS 流量。</p>\n\n        <h2 id=\"请求-响应格式\"   >\n          <a href=\"#请求-响应格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求-响应格式\" class=\"headerlink\" title=\"请求/响应格式\"></a>请求/响应格式</h2>\n      \n        <h3 id=\"请求网址\"   >\n          <a href=\"#请求网址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求网址\" class=\"headerlink\" title=\"请求网址\"></a>请求网址</h3>\n      <p>JSON-REST 映射支持网址编码形式的请求数据，HTTP 请求和响应主体使用 application/json 作为 Content-Type。HTTP 主体使用 JSON 数组来支持流式 RPC 方法，JSON 数组可能包含任意数量的 JSON 消息或错误状态 JSON 消息。</p>\n\n        <h3 id=\"长请求网址\"   >\n          <a href=\"#长请求网址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#长请求网址\" class=\"headerlink\" title=\"长请求网址\"></a>长请求网址</h3>\n      <p>网址具有实际长度限制，通常在 2k 到 8k 之间。此限制由一些浏览器和代理强制执行。如果您的 API 使用网址超过长度限制的 GET 请求，浏览器可能会拒绝此类请求。要避开此限制，客户端代码应使用 Content-Type 为 application/x-www-form-urlencoded 的 POST 请求，且 HTTP 标头为 X-HTTP-Method-Override: GET。该方法也适用于 DELETE 请求。</p>\n\n        <h3 id=\"HTTP-方法（动词）\"   >\n          <a href=\"#HTTP-方法（动词）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-方法（动词）\" class=\"headerlink\" title=\"HTTP 方法（动词）\"></a>HTTP 方法（动词）</h3>\n      <p>如果请求网址符合 REST 模型，则将其 HTTP 方法指定为 API 规范的一部分。特别是，每种 API 方法都必须符合基于 API 方法映射到的特定 HTTP 动词的 HTTP 协议的要求。如需了解详情，请参阅<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9\" >超文本传输协议</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>规范和 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc5789\" >PATCH 方法</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> RFC。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.1.1\" >安全方法</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>（如 HTTP GET 和 HEAD）不应表示检索以外的操作。具体来说，HTTP GET 应该安全，不应对客户端产生任何显而易见的副作用。</p>\n<p>HTTP 中的<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.1.2\" >幂等性</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>意味着多个相同请求产生的副作用与单个请求相同。GET、PUT 和 DELETE 是与风格指南相关的幂等 HTTP 方法。请注意，幂等性仅通过服务器副作用的形式表示，并未指定有关响应的任何内容。特别是对于不存在的资源，DELETE 应该返回 404 (Not Found)。</p>\n<p>HTTP POST 和 PATCH 既不安全也不具有幂等性。（PATCH 在 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc5789\" >RFC 5789</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> 中引入）</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>HTTP 动词</th>\n<th>安全</th>\n<th>幂等</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.3\" >GET</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.6\" >PUT</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>是</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.7\" >DELETE</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>是</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc2616#section-9.5\" >POST</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://datatracker.ietf.org/doc/html/rfc5789\" >PATCH</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"负载格式\"   >\n          <a href=\"#负载格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#负载格式\" class=\"headerlink\" title=\"负载格式\"></a>负载格式</h3>\n      <ul>\n<li>请求和响应应共享相同的 Content-Type，除非请求是带有 application/x-www-form-urlencoded 主体的 GET 或 POST。</li>\n<li>JSON 在 application/json MIME 类型中受支持。从 proto3 到 JSON 的映射在 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\" >JSON 映射</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>中正式指定。</li>\n<li>根据用于将请求字段映射到查询参数的相同 REST 样式映射规则，可以使用表单参数 (POST) 代替网址查询参数 (GET)。支持的 Content-Type 为 application/x-www-form-urlencoded。</li>\n</ul>\n\n        <h2 id=\"流式\"   >\n          <a href=\"#流式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流式\" class=\"headerlink\" title=\"流式\"></a>流式</h2>\n      \n        <h3 id=\"半双工与全双工\"   >\n          <a href=\"#半双工与全双工\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#半双工与全双工\" class=\"headerlink\" title=\"半双工与全双工\"></a>半双工与全双工</h3>\n      <p>HTTP 是一种请求响应协议，允许通过面向信息流的不同传输协议（如 TCP (HTTP/1.x)）或其多路复用变体 (SPDY、HTTP/2、QUIC) 传递其请求或响应主体。</p>\n<p>作为客户端开发人员，您的应用可以采用流式传输模式生成请求主体，即客户端流式传输。同样地，应用也可以采用流式传输模式使用响应主体，即服务器流式传输。</p>\n<p>但是，HTTP 规范未指定在请求正文仍处于挂起状态时是否允许服务器流式传输回响应正文（错误响应除外）。这种语义称为全双工流式传输。尽管许多 HTTP 客户端/服务器/代理软件确实支持全双工流式传输，即使 HTTP/1.1 也支持，但为了避免出现任何互操作性问题，基于 HTTP 的 Cloud API 仅限于半双工流式传输。</p>\n<p>默认情况下，Cloud API 中的出价 Bidi 流式传输方法会采用全双工语义。 也就是说，使用 HTTP 调用这样的方法是不安全的。如果流式传输方法仅为半双工（由服务器强制执行），则 API 文档应明确指定半双工行为。</p>\n<p>对于浏览器客户端，标准 HTTP 语义进一步受浏览器网络 API 的限制。目前，浏览器仅通过 XHR 或 Fetch 支持服务器流式传输通常遵循传输级别的帧处理方式）。Fetch API 可以使用 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/whatwg/streams\" >whatwg 流</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。</p>\n<p>由于浏览器的限制，需要浏览器支持的 Cloud API 必须避免采用客户端流式传输以及全双工流式传输，或者为浏览器客户端提供单独的 API。</p>\n<p>一般来说，通过互联网进行客户端流式传输不如服务器流式传输有用。这是因为使用客户端流式传输通常会导致有状态服务，这会对负载平衡造成负面影响，让系统更容易出现故障或受到攻击。另一方面，服务器流式传输可能很有用，因为它可以显着减少有长时间 RTT 延迟的网络上的延迟时间。</p>\n\n        <h3 id=\"消息编码\"   >\n          <a href=\"#消息编码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#消息编码\" class=\"headerlink\" title=\"消息编码\"></a>消息编码</h3>\n      <p>JSON 消息在流式传输时将作为 JSON 消息数组进行编码。请求或响应正文将作为有效的 JSON MIME 类型保留。</p>\n<p>客户端流式传输编码示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &lt;length&gt; &lt;message-bytes&gt; 1 &lt;length&gt; &lt;message-bytes&gt;  … EOF</span><br></pre></td></tr></table></div></figure>\n<p>服务器流式传输编码示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &lt;length&gt; &lt;message-bytes&gt;  … 2 &lt;length&gt; &lt;status-bytes&gt; EOF</span><br></pre></td></tr></table></div></figure>\n<p>线级编码：StreamBody 的定义仅在其为字段“messages”分配 tag-id 时才有意义，而“status”对于正常消息将采用 1-2 字节的 varint 编码，因此总的编码开销为每条消息 2-3 个字节</p>\n<p>需要添加可选的填充字段，才能支持使用 base64 编码的流：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">message StreamBody &#123;</span><br><span class=\"line\">  repeated bytes message &#x3D; 1;</span><br><span class=\"line\">  google.rpc.Status status &#x3D; 2;</span><br><span class=\"line\">  repeated bytes padding &#x3D; 15;   &#x2F;&#x2F; max one-byte tag-id: xxx01111</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>错误消息应作为 JSON 或 protobuf 数组的最后一个元素附加，其格式与常规消息相同。</p>\n\n        <h2 id=\"状态管理\"   >\n          <a href=\"#状态管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h2>\n      <p>适用于客户端或服务器的任何 HTTP 版本中都很好地定义了半关闭行为，旨在向另一端发送主体已完成的信号。</p>\n<p>特别是，客户端代码在等待响应时可以自由完成请求。与之类似，当请求主体仍在写入服务器时，客户端可能会看到完成的响应。HTTP 标准要求客户端在以意外方式完成响应时（通常具有错误状态）中止或完成请求。这就是说，在正常情况下，服务器不应在客户端仍在发送请求时完成响应。</p>\n\n        <h3 id=\"取消\"   >\n          <a href=\"#取消\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#取消\" class=\"headerlink\" title=\"取消\"></a>取消</h3>\n      <p>通过取消支持，客户端能够在请求或响应仍在等待处理时中止请求。</p>\n<p>HTTP/1.* 客户端没有可靠的取消支持，因为客户端可在请求完成后随时关闭 TCP 连接，而不会中止请求/响应事务。采用 HTTP/1.1 的 TCP FIN 不应被解释为取消，即使连接被标记为保持 keep-alive (Connection: Keep-Alive) 也是如此。</p>\n<p>但在客户端关闭 TCP 连接后，如果服务器尝试将任何数据写入客户端，则会生成 RST，这会触发取消。</p>\n<p>另请注意，取消也是非流式传输 API 存在的问题。当响应涉及长轮询并且因此导致连接长时间保持空闲时，此问题尤其明显。</p>\n<p>SPDY、HTTP/2 和 QUIC 支持显式取消，尤其是与 go-away 消息结合使用。</p>\n\n        <h3 id=\"Keep-alive\"   >\n          <a href=\"#Keep-alive\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Keep-alive\" class=\"headerlink\" title=\"Keep-alive\"></a>Keep-alive</h3>\n      <p>通过 Keep-alive 支持，客户端或服务器能够检测到失败的对等体，即使在出现丢包或网络故障的情况下也是如此。</p>\n<p>HTTP/1.1 不提供 keep-alive 支持，因为 TCP keep-alive 不是一种可行的方法。</p>\n<p>QUIC 或 HTTP/2 提供特殊控制消息，旨在实现由应用（包括浏览器）提供的 keep-alive 支持。</p>\n<p>但是，实现可靠的 keep-alive 和故障检测将可能需要有一个客户端库，加上必要的服务器端支持：如果依赖将基本 HTTP 作为通信协议，通过互联网进行长期流式传输通常容易出错。</p>\n\n        <h2 id=\"流控制\"   >\n          <a href=\"#流控制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#流控制\" class=\"headerlink\" title=\"流控制\"></a>流控制</h2>\n      <p>流控制支持要求客户端将传输级流控制事件传播到客户端应用。实际的机制取决于客户端应用所使用的 HTTP 客户端 API 执行机制。例如，为了防止客户端或服务器过载，您需要使用显式流控制支持阻塞写入和读取或者非阻塞读取和写入，以便应用处理和遵循流控制事件。</p>\n<p>HTTP/1.1 依赖于 TCP 流控制。</p>\n<p>SPDY 和 HTTP/2 在流级别具有自己的流控制，由于请求通过单个 TCP 连接进行多路复用，因此它们在连接级别进一步受到 TCP 流控制的限制。</p>\n<p>QUIC 在 UDP 上运行，因此可以完全自行管理流控制。</p>\n","categories":["http"],"tags":["http","Google API"]},{"title":"一条sql语句的执行过程","url":"/2020/01/14/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","content":"<p>比如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from T where ID&#x3D;10；</span><br></pre></td></tr></table></div></figure>\n<p>要想知道这条语句在 MySQL 内部的执行过程，需要把 MySQL 拆解一下看看里面都有哪些“零件”，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p>\n<a id=\"more\"></a>\n\n<p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p>\n<p>MySQL 的逻辑架构图</p>\n<p><img src=\"/images/mysql/mysql_base.png\" alt=\"mysql_base\"></p>\n<p>大体来说，MySQL 可以分为 Server 层和存储引擎层。</p>\n<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>\n<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>\n<p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p>\n<p>从图中不难看出，不同的存储引擎共用一个Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>\n<p>连接器<br>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></div></figure>\n<p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p>\n<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>\n<ul>\n<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>\n<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>\n</ul>\n<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>\n<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>\n<p><img src=\"/images/mysql/mysql_processlist.png\" alt=\"mysql_processlist\"></p>\n<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>\n<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>\n<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>\n<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>\n<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>\n<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>\n<p>2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>\n<p><strong>查询缓存</strong></p>\n<p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p>\n<p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>\n<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>\n<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>\n<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>\n<p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">select SQL_CACHE * from T where ID&#x3D;10</span><br></pre></td></tr></table></div></figure>\n<p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p>\n<p><strong>分析器</strong></p>\n<p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p>\n<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p>\n<p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串 “T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>\n<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>\n<p>如果你的语句不对，就会收到 “You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; elect * from t where ID&#x3D;1;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1</span><br></pre></td></tr></table></div></figure>\n<p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>\n<p><strong>优化器</strong></p>\n<p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>\n<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join:</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t1 join t2 using(ID) where t1.c&#x3D;10 and t2.d&#x3D;20</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>\n<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>\n</ul>\n<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>\n<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>\n<p><strong>执行器</strong></p>\n<p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>\n<p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t1 where id&#x3D;10;</span><br><span class=\"line\">ERROR 1142(42000) SELECT commend denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></div></figure>\n<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p>\n<p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>\n<p>1.调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；<br>2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br>3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集作为结果集返回给客户端。</p>\n<p>至此，这个语句就执行完成了。</p>\n<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>\n<p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>\n<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相的。</p>\n","categories":["MYSQL"],"tags":["mysql"]},{"title":"索引为何使用B+树","url":"/2020/10/12/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8B+%E6%A0%91/","content":"\n        <h2 id=\"问题思考\"   >\n          <a href=\"#问题思考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h2>\n      <p>数据库索引的数据结构有很多种，比如：哈希索引、平衡二叉树索引、B树索引、B+树索引等等。</p>\n<p>目前最流行的是B+树索引，那大家有没有想过为什么是B+树索引最流行，为什么其他索引应用不广泛</p>\n\n        <h2 id=\"哈希索引\"   >\n          <a href=\"#哈希索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#哈希索引\" class=\"headerlink\" title=\"哈希索引\"></a>哈希索引</h2>\n      <a id=\"more\"></a>\n\n<p>hash大家应该非常的熟悉，就是我们老生常谈的HashMap里用到的技术。Hash索引其检索效率非常高，索引的检索可以一次定位。</p>\n<p>既然Hash索引的效率这么高，为什么都用Hash索引而还要使用B-Tree索引呢?</p>\n<p>这是因为虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：</p>\n\n        <h3 id=\"1-原因一：\"   >\n          <a href=\"#1-原因一：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-原因一：\" class=\"headerlink\" title=\"1. 原因一：\"></a>1. 原因一：</h3>\n      <p><strong>Hash索引不能使用范围查询</strong></p>\n<p>Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询(注意&lt;&gt;和＜＝＞是不同的操作），不能使用范围查询，例如WHERE price &gt; 100。</p>\n<p>由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤。</p>\n\n        <h3 id=\"2-原因二：\"   >\n          <a href=\"#2-原因二：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-原因二：\" class=\"headerlink\" title=\"2. 原因二：\"></a>2. 原因二：</h3>\n      <p><strong>Hash索引不能利用部分索引键查询。</strong></p>\n<p>对于复合索引，Hash索引在计算Hash值的时候，是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值。</p>\n<p>所以通过复合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。</p>\n\n        <h3 id=\"3-原因三：\"   >\n          <a href=\"#3-原因三：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-原因三：\" class=\"headerlink\" title=\"3. 原因三：\"></a>3. 原因三：</h3>\n      <p><strong>Hash索引在任何时候都不能避免表扫描。</strong></p>\n<p>Hash索引是将索引键通过Hash运算之后，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中。</p>\n<p>由于不同索引键存在相同Hash值，所以无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p>\n\n        <h2 id=\"平衡二叉树索引\"   >\n          <a href=\"#平衡二叉树索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#平衡二叉树索引\" class=\"headerlink\" title=\"平衡二叉树索引\"></a>平衡二叉树索引</h2>\n      <p>平衡二叉树的结构特点：</p>\n<p><img src=\"https://luckylsx.github.io/images/mysql/mysql_avl_tree.png\" alt=\"mysql_avl_tree\"></p>\n<p>又称 AVL树。它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它的左子树和右子树都是平衡二叉树。</p>\n<p>且左子树和右子树的深度之差的绝对值（平衡因子 ）不超过1。也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。</p>\n\n        <h3 id=\"被淘汰的原因\"   >\n          <a href=\"#被淘汰的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#被淘汰的原因\" class=\"headerlink\" title=\"被淘汰的原因:\"></a>被淘汰的原因:</h3>\n      <ul>\n<li>树的高度过高，高度越高，查找速度越慢</li>\n<li>他支持范围查找，但是他需要在进行回旋查找</li>\n</ul>\n<p>比如我要找到大于5的数据</p>\n<p>第一步我先定位到5，然后在树上按照二叉树规则去回旋查找大于5其他数据6、7、8、9、10。。。</p>\n<p>如果大于5的数据很多，那速度是很慢的。</p>\n\n        <h2 id=\"B树索引\"   >\n          <a href=\"#B树索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#B树索引\" class=\"headerlink\" title=\"B树索引\"></a>B树索引</h2>\n      <p><img src=\"https://luckylsx.github.io/images/mysql/mysql_b_tree.png\" alt=\"mysql_b_tree\"></p>\n<p>大家可以看到B树和二叉树最大的区别在于：它一个节点可以存储两个值，这就意味着它的树高度，比二叉树的高度更低，它的查询速度就更快。这是他的优点</p>\n<p>那为什么最终还是不用它呢，还是因为他在范围查找的时候，存在回旋查询的问题。同样order by排序的时候效率也很低，因为要把树上的数据手动排序一遍。</p>\n\n        <h2 id=\"终极大佬：B-树\"   >\n          <a href=\"#终极大佬：B-树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#终极大佬：B-树\" class=\"headerlink\" title=\"终极大佬：B+树:\"></a>终极大佬：B+树:</h2>\n      <p><img src=\"https://luckylsx.github.io/images/mysql/mysql_b_plus_tree.png\" alt=\"mysql_b_plus_tree\"></p>\n<p>它是B数的升级版，B+树相比B树，新增叶子节点与非叶子节点关系。</p>\n<p>叶子节点中包含了key和value，key存储的是1-10这些数字，value存储的是数据存储地址，非叶子节点中只是包含了key，不包含value。</p>\n<p>所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高</p>\n\n        <h3 id=\"比如我们要查找大于5的数据：\"   >\n          <a href=\"#比如我们要查找大于5的数据：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#比如我们要查找大于5的数据：\" class=\"headerlink\" title=\"比如我们要查找大于5的数据：\"></a>比如我们要查找大于5的数据：</h3>\n      <ul>\n<li>首先我们定位到5的位置</li>\n<li>然后直接将5后面的数据全部拿出来即可，因为这是有序链表，已经排好序了</li>\n</ul>\n<p>我们在order by排序的时候为什么要使用索引进行排序，原因就在这。</p>\n","categories":["mysql"],"tags":["mysql","B+树","hash"]},{"title":"在线小工具","url":"/2021/05/29/%E5%9C%A8%E7%BA%BF%E5%B0%8F%E5%B7%A5%E5%85%B7/","content":"<p>本文记录了编程人员常用的工具集合，方便自己编程使用，也作为小工具箱方便大家查找。</p>\n\n        <h3 id=\"工具转换\"   >\n          <a href=\"#工具转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#工具转换\" class=\"headerlink\" title=\"工具转换\"></a>工具转换</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.lu/timestamp/\" >时间戳</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.lu/\" >很全的在线工具集合</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><a id=\"more\"></a></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://regexr.com/\" >正则表达式工具</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.lu/markdown/\" >markdown在线编辑器</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.json.cn/\" >json格式化</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://oktools.net/json2go\" >json 转 struct</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tool.jisuapi.com/base642pic.html\" >base64 转图片</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://tool.chinaz.com/tools/regexgenerate\" >正则表达式生成</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tinypng.com/\" >图片压缩</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"算法与数据结构\"   >\n          <a href=\"#算法与数据结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\" >数据结构动态演示</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://visualgo.net/zh\" >数据结构和算法动态可视化：visualgo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"查询类\"   >\n          <a href=\"#查询类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#查询类\" class=\"headerlink\" title=\"查询类\"></a>查询类</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ipaddress.com/\" >IP 地址查询</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.diffchecker.com/diff\" >内容差异比较</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://web.chacuo.net/netsslctcheck\" >网站证书信息查询</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><a href=\"www.jucha.com\">聚查网</a></li>\n</ul>\n\n        <h3 id=\"图标\"   >\n          <a href=\"#图标\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.iconfont.cn/\" >阿里巴巴矢量图标库</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"在线作图\"   >\n          <a href=\"#在线作图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#在线作图\" class=\"headerlink\" title=\"在线作图\"></a>在线作图</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.processon.com/;jsessionid=63AD3093802D99FD12D81FBD3881824F.jvm1\" >ProcessOn</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n\n        <h3 id=\"其他\"   >\n          <a href=\"#其他\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://idea.medeming.com/jet/\" >jetbrains激活码</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\" >nginx 证书生成</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://unbug.github.io/codelf/\" >中文智能转换变量</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://editor.mdnice.com/\" >微信公众号排版编辑</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.ddung.org/daili/\" >网站代理</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://xclient.info/\" >mac 软件下载</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://distrowatch.com/\" >开源操作系统最新信息</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["tool"],"tags":["tool"]},{"title":"MySQL数据库设计规范","url":"/2020/04/13/the-Mysql-Standards-Recommendation/","content":"\n        <h2 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 规范背景与目的\t</span><br><span class=\"line\"></span><br><span class=\"line\">2. 设计规范</span><br><span class=\"line\"></span><br><span class=\"line\">2.1 数据库设计\t</span><br><span class=\"line\"></span><br><span class=\"line\">2.1.1 库名\t</span><br><span class=\"line\">2.1.2 表结构\t</span><br><span class=\"line\">2.1.3 列数据类型优化\t</span><br><span class=\"line\">2.1.4 索引设计\t</span><br><span class=\"line\">2.1.5 分库分表、分区表\t</span><br><span class=\"line\">2.1.6 字符集\t</span><br><span class=\"line\">2.1.7 程序DAO层设计建议\t</span><br><span class=\"line\">2.1.8 一个规范的建表语句示例\t</span><br><span class=\"line\"></span><br><span class=\"line\">2.2 SQL编写\t</span><br><span class=\"line\"></span><br><span class=\"line\">2.2.1 DML语句\t</span><br><span class=\"line\">2.2.2 多表连接\t</span><br><span class=\"line\">2.2.3 事务\t</span><br><span class=\"line\">2.2.4 排序和分组\t</span><br><span class=\"line\">2.2.5 线上禁止使用的SQL语句</span><br></pre></td></tr></table></div></figure>\n<a id=\"more\"></a>\n\n\n\n        <h2 id=\"1-规范背景与目的\"   >\n          <a href=\"#1-规范背景与目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-规范背景与目的\" class=\"headerlink\" title=\"1. 规范背景与目的\"></a>1. 规范背景与目的</h2>\n      <p>MySQL数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。</p>\n\n        <h2 id=\"2-设计规范\"   >\n          <a href=\"#2-设计规范\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-设计规范\" class=\"headerlink\" title=\"2. 设计规范\"></a>2. 设计规范</h2>\n      \n        <h3 id=\"2-1-数据库设计\"   >\n          <a href=\"#2-1-数据库设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-数据库设计\" class=\"headerlink\" title=\"2.1 数据库设计\"></a>2.1 数据库设计</h3>\n      <p>以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。</p>\n<p>对于不满足【高危】和【强制】两个级别的设计，DBA会强制打回要求修改。</p>\n\n        <h4 id=\"2-1-1-库名\"   >\n          <a href=\"#2-1-1-库名\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-1-库名\" class=\"headerlink\" title=\"2.1.1 库名\"></a>2.1.1 库名</h4>\n      <p>1.【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量提现join的关系，如user表和user_login表。</p>\n<p>2.【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。</p>\n<p>3.【强制】一般分库名称命名格式是库通配名_编号，编号从0开始递增，比如wenda_001以时间进行分库的名称格式是“库通配名_时间”</p>\n<p>4.【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：create database db1 default character set utf8;。</p>\n\n        <h4 id=\"2-1-2-表结构\"   >\n          <a href=\"#2-1-2-表结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-2-表结构\" class=\"headerlink\" title=\"2.1.2 表结构\"></a>2.1.2 表结构</h4>\n      <p>1.【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。</p>\n<p>2.【强制】表名要求模块名强相关，如师资系统采用”sz”作为前缀，渠道系统采用”qd”作为前缀等。</p>\n<p>3.【强制】创建表时必须显式指定字符集为utf8或utf8mb4。</p>\n<p>4.【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB/MyISAM/Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB。</p>\n<p>5.【强制】建表必须有comment</p>\n<p>6.【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint，且为auto_increment。(2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引（可参考cdb.teacher表设计）。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降。</p>\n<p>7.【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段create_time和最后更新时间字段update_time，便于查问题。</p>\n<p>8.【建议】表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p>\n<p>9.【建议】建议对表里的blob、text等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select。</p>\n<p>10.【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如user_name属性在user_account，user_login_log等表里冗余一份，减少join查询。</p>\n<p>11.【强制】中间表用于保留中间结果集，名称必须以tmp_开头。备份表用于备份或抓取源表快照，名称必须以bak_开头。中间表和备份表定期清理。</p>\n<p>12.【强制】对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行。因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>\n\n        <h4 id=\"2-1-3-列数据类型优化\"   >\n          <a href=\"#2-1-3-列数据类型优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-3-列数据类型优化\" class=\"headerlink\" title=\"2.1.3 列数据类型优化\"></a>2.1.3 列数据类型优化</h4>\n      <p>1.【建议】表中的自增列（auto_increment属性），推荐使用bigint类型。因为无符号int存储范围为-2147483648~2147483647（大约21亿左右），溢出后会导致报错。</p>\n<p>2.【建议】业务中选择性很少的状态status、类型type等字段推荐使用tinytint或者smallint类型节省存储空间。</p>\n<p>3.【建议】业务中IP地址字段推荐使用int类型，不推荐用char(15)。因为int只占4字节，可以用如下函数相互转换，而char(15)占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。SQL：select inet_aton(‘192.168.2.12’); select inet_ntoa(3232236044); PHP: ip2long(‘192.168.2.12’); long2ip(3530427185);</p>\n<p>4.【建议】不推荐使用enum，set。因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用tinyint或smallint。</p>\n<p>5.【建议】不推荐使用blob，text等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段。Innodb中当一行记录超过8098字节时，会将该记录中选取最长的一个字段将其768字节放在原始page里，该字段余下内容放在overflow-page里。不幸的是在compact行格式下，原始page和overflow-page都会加载。</p>\n<p>6.【建议】存储金钱的字段，建议用int，程序端乘以100和除以100进行存取。因为int占用4字节，而double占用8字节，空间浪费。</p>\n<p>7.【建议】文本数据尽量用varchar存储。因为varchar是变长存储，比char更省空间。MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为mediumtext字段。而text在utf8字符集下最多存21844个字符，mediumtext最多存2^24/3个字符，longtext最多存2^32个字符。一般建议用varchar类型，字符数不要超过2700。</p>\n<p>8.【建议】时间类型尽量选取timestamp。因为datetime占用8字节，timestamp仅占用4字节，但是范围为1970-01-01 00:00:01到2038-01-01 00:00:00。更为高阶的方法，选用int来存储时间，使用SQL函数unix_timestamp()和from_unixtime()来进行转换。</p>\n<p>详细存储大小参加下图：</p>\n<p><img src=\"https://luckylsx.github.io/images/mysql/mysql_time_type.png\" alt=\"mysql_time_base\"></p>\n\n        <h4 id=\"2-1-4-索引设计\"   >\n          <a href=\"#2-1-4-索引设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-4-索引设计\" class=\"headerlink\" title=\"2.1.4 索引设计\"></a>2.1.4 索引设计</h4>\n      <p>1.【强制】InnoDB表必须主键为id int/bigint auto_increment,且主键值禁止被更新。</p>\n<p>2.【建议】主键的名称以“pk_”开头，唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀。</p>\n<p>3.【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引。</p>\n<p>4.【强制】单个索引中每个索引记录的长度不能超过64KB。</p>\n<p>5.【建议】单个表上的索引个数不能超过7个。</p>\n<p>6.【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列userid的区分度可由select count(distinct userid)计算出来。</p>\n<p>7.【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</p>\n<p>8.【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。</p>\n\n        <h4 id=\"2-1-5-分库分表、分区表\"   >\n          <a href=\"#2-1-5-分库分表、分区表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-5-分库分表、分区表\" class=\"headerlink\" title=\"2.1.5 分库分表、分区表\"></a>2.1.5 分库分表、分区表</h4>\n      <p>1.【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列。</p>\n<p>2.【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</p>\n<p>3.【强制】上线前RD或者DBA必须指定分区表的创建、清理策略。</p>\n<p>4.【强制】访问分区表的SQL必须包含分区键。</p>\n<p>5.【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个。</p>\n<p>6.【强制】对于分区表执行alter table操作，必须在业务低峰期执行。</p>\n<p>7.【强制】采用分库策略的，库的数量不能超过1024</p>\n<p>8.【强制】采用分表策略的，表的数量不能超过4096</p>\n<p>9.【建议】单个分表不超过500W行，ibd文件大小不超过2G，这样才能让数据分布式变得性能更佳。</p>\n<p>10.【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。</p>\n\n        <h4 id=\"2-1-6-字符集\"   >\n          <a href=\"#2-1-6-字符集\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-6-字符集\" class=\"headerlink\" title=\"2.1.6 字符集\"></a>2.1.6 字符集</h4>\n      <p>1.【强制】数据库本身库、表、列所有字符集必须保持一致，为utf8或utf8mb4。</p>\n<p>2.【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为utf8。</p>\n\n        <h4 id=\"2-1-7-程序层DAO设计建议\"   >\n          <a href=\"#2-1-7-程序层DAO设计建议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-7-程序层DAO设计建议\" class=\"headerlink\" title=\"2.1.7 程序层DAO设计建议\"></a>2.1.7 程序层DAO设计建议</h4>\n      <p>1.【建议】新的代码不要用model，推荐使用手动拼SQL+绑定变量传入参数的方式。因为model虽然可以使用面向对象的方式操作db，但是其使用不当很容易造成生成的SQL非常复杂，且model层自己做的强制类型转换性能较差，最终导致数据库性能下降。</p>\n<p>2.【建议】前端程序连接MySQL或者redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。</p>\n<p>3.【建议】前端程序报错里尽量能够提示MySQL或redis原生态的报错信息，便于排查错误。</p>\n<p>4.【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。</p>\n<p>5.【建议】对于log或history类型的表，随时间增长容易越来越大，因此上线前RD或者DBA必须建立表数据清理或归档方案。</p>\n<p>6.【建议】在应用程序设计阶段，RD必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。</p>\n<p>7.【建议】多个并发业务逻辑访问同一块数据（innodb表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类SQL尽量基于主键去更新。</p>\n<p>8.【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。</p>\n<p>9.【建议】对于单表读写比大于10:1的数据行或单个列，可以将热点数据放在缓存里（如mecache或redis），加快访问速度，降低MySQL压力。</p>\n\n        <h4 id=\"2-1-8-一个规范的建表语句示例\"   >\n          <a href=\"#2-1-8-一个规范的建表语句示例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-1-8-一个规范的建表语句示例\" class=\"headerlink\" title=\"2.1.8 一个规范的建表语句示例\"></a>2.1.8 一个规范的建表语句示例</h4>\n      <p><strong>一个较为规范的建表语句为：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE user (</span><br><span class=\"line\">  &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  &#96;user_id&#96; bigint(11) NOT NULL COMMENT ‘用户id’</span><br><span class=\"line\">  &#96;username&#96; varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;,</span><br><span class=\"line\">  &#96;email&#96; varchar(30) NOT NULL COMMENT ‘用户邮箱’,</span><br><span class=\"line\">  &#96;nickname&#96; varchar(45) NOT NULL COMMENT &#39;昵称&#39;,</span><br><span class=\"line\">  &#96;avatar&#96; int(11) NOT NULL COMMENT &#39;头像&#39;,</span><br><span class=\"line\">  &#96;birthday&#96; date NOT NULL COMMENT &#39;生日&#39;,</span><br><span class=\"line\">  &#96;sex&#96; tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,</span><br><span class=\"line\">  &#96;short_introduce&#96; varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,</span><br><span class=\"line\">  &#96;user_resume&#96; varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,</span><br><span class=\"line\">  &#96;user_register_ip&#96; int NOT NULL COMMENT ‘用户注册时的源ip’,</span><br><span class=\"line\">  &#96;create_time&#96; timestamp NOT NULL COMMENT ‘用户记录创建的时间’,</span><br><span class=\"line\">  &#96;update_time&#96; timestamp NOT NULL COMMENT ‘用户资料修改的时间’,</span><br><span class=\"line\">  &#96;user_review_status&#96; tinyint NOT NULL COMMENT ‘用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核’,</span><br><span class=\"line\">  PRIMARY KEY (&#96;id&#96;),</span><br><span class=\"line\">  UNIQUE KEY &#96;idx_user_id&#96; (&#96;user_id&#96;),</span><br><span class=\"line\">  KEY &#96;idx_username&#96;(&#96;username&#96;),</span><br><span class=\"line\">  KEY &#96;idx_create_time&#96;(&#96;create_time&#96;,&#96;user_review_status&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;网站用户基本信息&#39;;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"2-2-SQL编写\"   >\n          <a href=\"#2-2-SQL编写\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-SQL编写\" class=\"headerlink\" title=\"2.2 SQL编写\"></a>2.2 SQL编写</h3>\n      \n        <h4 id=\"2-2-1-DML语句\"   >\n          <a href=\"#2-2-1-DML语句\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-1-DML语句\" class=\"headerlink\" title=\"2.2.1 DML语句\"></a>2.2.1 DML语句</h4>\n      <p>1.【强制】SELECT语句必须指定具体字段名称，禁止写成*。因为select *会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但model层没有来得及更新的话，系统会报错。</p>\n<p>2.【强制】insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上。</p>\n<p>3.【建议】insert into…values(XX),(XX),(XX)…。这里XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。</p>\n<p>4.【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。因为union all不需要去重，节省数据库资源，提高性能。</p>\n<p>5.【建议】in值列表限制在500以内。例如select… where userid in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</p>\n<p>6.【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。</p>\n<p>7.【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。</p>\n<p>8.【强制】写入和事务发往主库，只读SQL发往从库。</p>\n<p>9.【强制】除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。</p>\n<p>10.【强制】生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等。因为hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信MySQL优化器！</p>\n<p>11.【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</p>\n<p>12.【建议】SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找。</p>\n<p>13.【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引。</p>\n<p>14.【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</p>\n<p>15.【建议】索引列不要使用函数或表达式，否则无法利用索引。如where length(name)=’Admin’或where user_id+2=10023。</p>\n<p>16.【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索</p>\n<p>17.【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select a,b,c from t1 limit 10000,20;优化为: select a,b,c from t1 where id&gt;10000 limit 20;。</p>\n\n        <h4 id=\"2-2-2-多表连接\"   >\n          <a href=\"#2-2-2-多表连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-2-多表连接\" class=\"headerlink\" title=\"2.2.2 多表连接\"></a>2.2.2 多表连接</h4>\n      <p>1.【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。</p>\n<p>2.【强制】禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…。</p>\n<p>3.【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</p>\n<p>4.【建议】线上环境，多表join不要超过3个表。</p>\n<p>5.【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如select a from db1.table1 alias1 where …。</p>\n<p>6.【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</p>\n\n        <h4 id=\"2-2-3-事务\"   >\n          <a href=\"#2-2-3-事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-3-事务\" class=\"headerlink\" title=\"2.2.3 事务\"></a>2.2.3 事务</h4>\n      <p>1.【建议】事务中INSERT|UPDATE|DELETE|REPLACE语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内。</p>\n<p>2.【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值5-10秒。</p>\n<p>3.【建议】对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内。</p>\n<p>4.【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为repeatable-read。</p>\n<p>5.【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。</p>\n<p>6.【建议】事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p>\n<p>7.【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。</p>\n<p>8.【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库。</p>\n\n        <h4 id=\"2-2-4-排序和分组\"   >\n          <a href=\"#2-2-4-排序和分组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-4-排序和分组\" class=\"headerlink\" title=\"2.2.4 排序和分组\"></a>2.2.4 排序和分组</h4>\n      <p>1.【建议】减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p>\n<p>2.【建议】order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b)。</p>\n<p>3.【建议】包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p>\n\n        <h4 id=\"2-2-5-线上禁止使用的SQL语句\"   >\n          <a href=\"#2-2-5-线上禁止使用的SQL语句\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-2-5-线上禁止使用的SQL语句\" class=\"headerlink\" title=\"2.2.5 线上禁止使用的SQL语句\"></a>2.2.5 线上禁止使用的SQL语句</h4>\n      <p>1.【高危】禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK。</p>\n<p>2.【高危】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下。</p>\n<p>3.【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。</p>\n<p>4.【强制】禁用insert into …on duplicate key update…在高并发环境下，会造成主从不一致。</p>\n<p>5.【强制】禁用insert into …on duplicate key update…在高并发环境下，会造成主从不一致。</p>\n","categories":["MYSQL"],"tags":["mysql"]},{"title":"go实现各类限流算法","url":"/2021/05/30/go%E5%AE%9E%E7%8E%B0%E5%90%84%E7%B1%BB%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/","content":"\n        <h2 id=\"介绍\"   >\n          <a href=\"#介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2>\n      <p>限流是一种编程中常用的保护服务正常运行的一种方案；为了应对激增的流量，防止服务被击垮，经常使用某种算法来对流量进行某种限流，以保证后端服务的正常运行。</p>\n<p>本文介绍 计数器、令牌桶算法和楼桶算法及它们之间的优缺点。</p>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"计数器\"   >\n          <a href=\"#计数器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Counter Counter</span><br><span class=\"line\">type Counter struct &#123;</span><br><span class=\"line\">\trate  int</span><br><span class=\"line\">\tbegin time.Time</span><br><span class=\"line\">\tcycle time.Duration</span><br><span class=\"line\">\tcount int</span><br><span class=\"line\">\tlock  sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Set Set</span><br><span class=\"line\">func (c *Counter) Set(r int, cycle time.Duration) &#123;</span><br><span class=\"line\">\tc.rate &#x3D; r</span><br><span class=\"line\">\tc.begin &#x3D; time.Now()</span><br><span class=\"line\">\tc.cycle &#x3D; cycle</span><br><span class=\"line\">\tc.count &#x3D; 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Reset Reset</span><br><span class=\"line\">func (c *Counter) Reset(t time.Time) &#123;</span><br><span class=\"line\">\tc.begin &#x3D; t</span><br><span class=\"line\">\tc.count &#x3D; 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Allow Allow</span><br><span class=\"line\">func (c *Counter) Allow() bool &#123;</span><br><span class=\"line\">\tc.lock.Lock()</span><br><span class=\"line\">\tdefer c.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif c.count &#x3D;&#x3D; c.rate &#123;</span><br><span class=\"line\">\t\tnow :&#x3D; time.Now()</span><br><span class=\"line\">\t\tif now.Sub(c.begin) &gt;&#x3D; c.cycle &#123;</span><br><span class=\"line\">\t\t\tc.Reset(now)</span><br><span class=\"line\">\t\t\treturn true</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn false</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tc.count++</span><br><span class=\"line\">\t\treturn true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tvar wg sync.WaitGroup</span><br><span class=\"line\">\tlr :&#x3D; new(Counter)</span><br><span class=\"line\">\tlr.Set(3, time.Second)</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(1)</span><br><span class=\"line\">\t\tlog.Println(&quot;创建请求:&quot;, i)</span><br><span class=\"line\">\t\tgo func(i int) &#123;</span><br><span class=\"line\">\t\t\tif lr.Allow() &#123;</span><br><span class=\"line\">\t\t\t\tlog.Println(&quot;request allw: &quot;, i)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t\ttime.Sleep(200 * time.Millisecond)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题，我们看下图：<br><img src=\"/images/golang/limit/counter.png\" alt=\"counter\"><br>从上图中我们可以看到，假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。</p>\n\n        <h2 id=\"令牌桶算法\"   >\n          <a href=\"#令牌桶算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h2>\n      <p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p>\n<img src=\"/images/golang/limit/token-bucket.png\" art=\"token-bucket\" width=\"500px\">\n\n<ul>\n<li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li>\n<li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>\n<li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li>\n<li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>\n</ul>\n<p>官方实现：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pkg.go.dev/golang.org/x/time/rate\" >https://pkg.go.dev/golang.org/x/time/rate</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"通过-time-rate-包实现\"   >\n          <a href=\"#通过-time-rate-包实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#通过-time-rate-包实现\" class=\"headerlink\" title=\"通过 time/rate 包实现\"></a>通过 time/rate 包实现</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 构建限流对象</span><br><span class=\"line\">&#x2F;&#x2F; NewLimiter returns a new Limiter that allows events up to rate r and permits</span><br><span class=\"line\">&#x2F;&#x2F; bursts of at most b tokens.</span><br><span class=\"line\">func NewLimiter(r Limit, b int) *Limiter &#123;</span><br><span class=\"line\">    return &amp;Limiter&#123;</span><br><span class=\"line\">        limit: r,</span><br><span class=\"line\">        burst: b,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Allow/AllowN 判断是否允许通过</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Allow is shorthand for AllowN(time.Now(), 1).</span><br><span class=\"line\">func (lim *Limiter) Allow() bool &#123;</span><br><span class=\"line\">    return lim.AllowN(time.Now(), 1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; AllowN reports whether n events may happen at time now.</span><br><span class=\"line\">&#x2F;&#x2F; Use this method if you intend to drop &#x2F; skip events that exceed the rate limit.</span><br><span class=\"line\">&#x2F;&#x2F; Otherwise use Reserve or Wait.</span><br><span class=\"line\">func (lim *Limiter) AllowN(now time.Time, n int) bool &#123;</span><br><span class=\"line\">    return lim.reserveN(now, n, 0).ok</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>具体细节，请看官方实现。</p>\n\n        <h3 id=\"自己手动实现\"   >\n          <a href=\"#自己手动实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自己手动实现\" class=\"headerlink\" title=\"自己手动实现\"></a>自己手动实现</h3>\n      <p>demo示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;math&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type tokenBucket struct &#123;</span><br><span class=\"line\">\trate     int64 &#x2F;&#x2F; 速率</span><br><span class=\"line\">\tcapacity int64 &#x2F;&#x2F; 桶容量</span><br><span class=\"line\">\ttokens   int64 &#x2F;&#x2F; 桶内token 个数</span><br><span class=\"line\">\tlastTime time.Time</span><br><span class=\"line\">\tlock sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *tokenBucket) allow() bool &#123;</span><br><span class=\"line\">\tt.lock.Lock()</span><br><span class=\"line\">\tdefer t.lock.Unlock()</span><br><span class=\"line\">\tnow :&#x3D; time.Now()</span><br><span class=\"line\">\tt.tokens &#x3D; t.tokens + int64(now.Sub(t.lastTime).Seconds() * float64(t.rate))</span><br><span class=\"line\">\tt.tokens &#x3D; int64(math.Min(float64(t.tokens), float64(t.capacity)))</span><br><span class=\"line\">\tif t.tokens &gt; 0 &#123;</span><br><span class=\"line\">\t\tt.lastTime &#x3D; now</span><br><span class=\"line\">\t\tt.tokens--</span><br><span class=\"line\">\t\treturn true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewTokenBucket(r, c int64) *tokenBucket &#123;</span><br><span class=\"line\">\treturn &amp;tokenBucket&#123;</span><br><span class=\"line\">\t\trate:     r,</span><br><span class=\"line\">\t\tcapacity: c,</span><br><span class=\"line\">\t\ttokens:   0,</span><br><span class=\"line\">\t\tlastTime: time.Now(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>测试，此时每5个请求，一个请求成功</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tt :&#x3D; NewTokenBucket(2, 5)</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class=\"line\">\t\ttime.Sleep(time.Millisecond * 100)</span><br><span class=\"line\">\t\tif ok :&#x3D; t.allow(); ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;request allow!&quot;)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;request deny!&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request deny!</span><br><span class=\"line\">request allow!</span><br><span class=\"line\">...</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"漏桶算法\"   >\n          <a href=\"#漏桶算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h2>\n      <p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：</p>\n<ul>\n<li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li>\n<li>如果桶是空的，则不需流出水滴。</li>\n<li>可以以任意速率流入水滴到漏桶。</li>\n<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li>\n</ul>\n<p>leaky-bucket rate limit algorithm:<br><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pkg.go.dev/go.uber.org/ratelimit\" >https://pkg.go.dev/go.uber.org/ratelimit</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h3 id=\"uber-ratelimit-官方实现\"   >\n          <a href=\"#uber-ratelimit-官方实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#uber-ratelimit-官方实现\" class=\"headerlink\" title=\"uber ratelimit 官方实现\"></a>uber ratelimit 官方实现</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&quot;go.uber.org&#x2F;ratelimit&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    rl :&#x3D; ratelimit.New(100) &#x2F;&#x2F; per second</span><br><span class=\"line\"></span><br><span class=\"line\">    prev :&#x3D; time.Now()</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 此处会被阻塞，直到请求允许通过</span><br><span class=\"line\">        &#x2F;&#x2F; Take should block to make sure that the RPS is met.</span><br><span class=\"line\">        now :&#x3D; rl.Take()</span><br><span class=\"line\">        fmt.Println(i, now.Sub(prev))</span><br><span class=\"line\">        prev &#x3D; now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Output:</span><br><span class=\"line\">    &#x2F;&#x2F; 0 0</span><br><span class=\"line\">    &#x2F;&#x2F; 1 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 2 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 3 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 4 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 5 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 6 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 7 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 8 10ms</span><br><span class=\"line\">    &#x2F;&#x2F; 9 10ms</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"自己实现\"   >\n          <a href=\"#自己实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自己实现\" class=\"headerlink\" title=\"自己实现\"></a>自己实现</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;math&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type LeakBucket struct &#123;</span><br><span class=\"line\">\trate       float64 &#x2F;&#x2F; 固定每秒出水率</span><br><span class=\"line\">\tcapacity   float64 &#x2F;&#x2F; 桶容量</span><br><span class=\"line\">\twater      float64 &#x2F;&#x2F; 桶中当前水量</span><br><span class=\"line\">\tlastLeakMs int64   &#x2F;&#x2F; 上次漏水时间戳</span><br><span class=\"line\">\tlock       sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (l *LeakBucket) Allow() bool &#123;</span><br><span class=\"line\">\tl.lock.Lock()</span><br><span class=\"line\">\tdefer l.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tnow :&#x3D; time.Now().UnixNano() &#x2F; 1e6</span><br><span class=\"line\">\teclipse :&#x3D; float64(now-l.lastLeakMs) * l.rate &#x2F; 1000</span><br><span class=\"line\">\tl.water &#x3D; l.water - eclipse</span><br><span class=\"line\">\tl.water &#x3D; math.Max(0, l.water)</span><br><span class=\"line\">\tif (l.water + 1) &lt; l.capacity &#123;</span><br><span class=\"line\">\t\tl.lastLeakMs &#x3D; now</span><br><span class=\"line\">\t\tl.water++</span><br><span class=\"line\">\t\treturn true</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func newBucket(r float64, c float64) *LeakBucket &#123;</span><br><span class=\"line\">\treturn &amp;LeakBucket&#123;</span><br><span class=\"line\">\t\trate:       r,</span><br><span class=\"line\">\t\tcapacity:   c,</span><br><span class=\"line\">\t\twater:      0,</span><br><span class=\"line\">\t\tlastLeakMs: time.Now().UnixNano() &#x2F; 1e6,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>计数器<br>漏桶算法 流出的速率是固定的，与令牌桶算法不同的是，令牌桶算法是放入的速率固定，取出的速率不固定，所以令牌桶算法支持流量的爆发。</p>\n","categories":["golang"],"tags":["golang","limiter"]},{"title":"rpc的核心原理-rpc的通信流程","url":"/2021/06/02/rpc%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-rpc%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/","content":"<p>RPC 是解决分布式系统通信问题的一大利器。</p>\n<p>分布式系统中的网络通信一般都会采用四层的 TCP 协议或七层的 HTTP 协议，前者占大多数，这主要得益于 TCP 协议的稳定性和高效性。网络通信说起来简单，但实际上是一个非常复杂的过程，这个过程主要包括：对端节点的查找、网络连接的建立、传输数据的编码解码以及网络连接的管理等等，每一项都很复杂。</p>\n<a id=\"more\"></a>\n\n<p>而 RPC 对网络通信的整个过程做了完整包装，在搭建分布式系统时，它会使网络通信逻辑的开发变得更加简单，同时也会让网络通信变得更加安全可靠。</p>\n\n        <h3 id=\"什么是RPC\"   >\n          <a href=\"#什么是RPC\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC?\"></a>什么是RPC?</h3>\n      <p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单从字面上来看，是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序，就可以称之为 RPC 调用了？显然并不够。</p>\n<p>RPC 是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。</p>\n<p>RPC 的作用就是体现在两个方面：</p>\n<ul>\n<li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li>\n<li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</li>\n</ul>\n\n        <h3 id=\"RPC的通信流程\"   >\n          <a href=\"#RPC的通信流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RPC的通信流程\" class=\"headerlink\" title=\"RPC的通信流程\"></a>RPC的通信流程</h3>\n      <p>一个完整的 RPC 会涉及到哪些步骤呢？</p>\n<p>RPC 是一个远程调用，需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。</p>\n<p>调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方从 TCP 通道里面收到二进制数据，那如何知道一个请求的数据到哪里结束，是一个什么类型的请求呢？这里就需要用到相关协议，而协议的作用就是做相关规定和约束。</p>\n<p>大多数的协议会分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。</p>\n<p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作“反序列化”。</p>\n<p>服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p>\n\n        <h3 id=\"完整的RPC通信流程\"   >\n          <a href=\"#完整的RPC通信流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#完整的RPC通信流程\" class=\"headerlink\" title=\"完整的RPC通信流程\"></a>完整的RPC通信流程</h3>\n      <p>如Spring的AOP技术，其核心是采用动态代理的技术，通过字节码增强对方法进行拦截增强，以便于增加需要的额外处理逻辑。其实这个技术也可以应用到 RPC 场景来解决我们刚才面临的问题。</p>\n<p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。</p>\n<p><img src=\"/images/golang/rpc/rpc-call-procedure.jpg\" alt=\"rpc_procedure\"></p>\n\n        <h3 id=\"RPC在架构中的位置\"   >\n          <a href=\"#RPC在架构中的位置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#RPC在架构中的位置\" class=\"headerlink\" title=\"RPC在架构中的位置\"></a>RPC在架构中的位置</h3>\n      <p>如刚才所讲，RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从“单体”演进成“微服务化”，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是“经络”一样的存在。</p>\n<p>RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。</p>\n<p>利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p>\n\n        <h3 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n      <p>RPC 就是提供一种透明调用机制，让使用者不必显式地区分本地调用和远程调用。RPC 虽然可以帮助开发者屏蔽远程调用跟本地调用的区别，但毕竟涉及到远程网络通信，所以这里还是有很多使用上的区别，比如：</p>\n<ul>\n<li>调用过程中超时了怎么处理业务？</li>\n<li>什么场景下最适合使用 RPC？</li>\n<li>什么时候才需要考虑开启压缩？</li>\n</ul>\n\n        <h3 id=\"课程来源\"   >\n          <a href=\"#课程来源\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#课程来源\" class=\"headerlink\" title=\"课程来源\"></a>课程来源</h3>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://time.geekbang.org/column/intro/100046201\" >https://time.geekbang.org/column/intro/100046201</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>欢迎大家订购，一块儿学习，共同进步。</p>\n","categories":["RPC"],"tags":["rpc"]},{"title":"grpc 内置protobuf类型使用","url":"/2021/06/08/grpc%E5%86%85%E7%BD%AEprotobuf%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/","content":"<p>介绍内置protobuf 类型使用过程中，使用 B站开源框架 kratos 作为示例demo,kratos 框架会同时生成http代码及rpc代码，方便演示。<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/go-kratos/kratos\" >kratos详细了解</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>使用protocal buffers 定义传参类型时，经常会遇到复杂场景及一些特殊情况需要定义proto文件的message，本文介绍protocal buffers内置数据类型的使用场景及使用示例。由于个人水平有限，如有不当之处还请指正。</p>\n\n        <h2 id=\"空请求-empty-类型\"   >\n          <a href=\"#空请求-empty-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#空请求-empty-类型\" class=\"headerlink\" title=\"空请求 empty 类型\"></a>空请求 empty 类型</h2>\n      <p>适用无传参或返回的message 类型，但通常不建议使用，为了更好的向后兼容，通常定义一个空的message。</p>\n<a id=\"more\"></a>\n\n<p><strong>proto定义</strong></p>\n<p>需要导入 google/protobuf/empty.proto 包。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;empty.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">rpc SayEmpty (google.protobuf.Empty) returns (HelloReply)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      get: &quot;&#x2F;helloworld&#x2F;&#123;name&#125;&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>service 层使用方法，则需要导入 emptypb 包</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google.golang.org&#x2F;protobuf&#x2F;types&#x2F;known&#x2F;emptypb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *GreeterService) SayEmpty(ctx context.Context, _ *emptypb.Empty)  (*v1.HelloReply, error) &#123;</span><br><span class=\"line\">\treturn &amp;v1.HelloReply&#123;Message: &quot;Hello empty&quot;&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>空message表示，无传参或返回具体数据，但为了更好的兼容，通常不建议这样做。</p>\n\n        <h2 id=\"wrappers-类型\"   >\n          <a href=\"#wrappers-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#wrappers-类型\" class=\"headerlink\" title=\"wrappers 类型\"></a>wrappers 类型</h2>\n      <p>用于区分参数为空及默认值场景。</p>\n<p>protocal buffers  定义的message 中，参数值默认为类型的默认值，即：bool 类型默认为 false, int32，int64 默认为 0，string 默认为空字符串等等。</p>\n<p>如何区分本身是默认值还是传参数为空呢？这里就需要用到wrappers包的相关类型。</p>\n<p><strong>proto 定义：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;wrappers.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloIsDefaultRequest &#123;</span><br><span class=\"line\">  string name &#x3D; 1;</span><br><span class=\"line\">  google.protobuf.Int32Value age &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>service 使用：</strong></p>\n<p>可通过值是否为 nil 来判断是否为默认值还是传参为类型的0值。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) IsDefault(ctx context.Context, in *v1.HelloIsDefaultRequest) (*v1.HelloDefaultReply, error)  &#123;</span><br><span class=\"line\">\tvar age int32 &#x3D; 18</span><br><span class=\"line\">\tif in.GetAge() !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tage &#x3D; in.GetAge().GetValue()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn &amp;v1.HelloDefaultReply&#123;</span><br><span class=\"line\">\t\tName: in.GetName(),</span><br><span class=\"line\">\t\tAge:  age,</span><br><span class=\"line\">\t&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>wrappers包下可包装的类型有多个，有： Int32Value， Int64Value， BoolValue， ListValue， NullValue， StringValue， BytesValue等多种类型，具体了解，可查看代码。</p>\n\n        <h2 id=\"FieldMask-类型\"   >\n          <a href=\"#FieldMask-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#FieldMask-类型\" class=\"headerlink\" title=\"FieldMask 类型\"></a>FieldMask 类型</h2>\n      <p>个人在使用过程中，主要用于更新方法，通过传参FieldMask 来控制更新字段</p>\n<p><strong>proto定义</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;field_mask.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc FiledMask (HelloFieldMaskRequest) returns (HelloFieldMaskResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;fieldMask&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloFieldMaskRequest &#123;</span><br><span class=\"line\">  int32 task_id &#x3D; 1;</span><br><span class=\"line\">  bool is_delete &#x3D; 2;</span><br><span class=\"line\">  bool is_finished &#x3D; 3;</span><br><span class=\"line\">  google.protobuf.FieldMask field_mask &#x3D; 4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloFieldMaskResponse &#123;</span><br><span class=\"line\">  repeated string field_mask &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>service 接收示例：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) FiledMask(ctx context.Context, in *v1.HelloFieldMaskRequest) (*v1.HelloFieldMaskResponse, error)  &#123;</span><br><span class=\"line\">\ts.log.Infof(&quot;task_id &#x3D; %+v&quot;, in.GetTaskId())</span><br><span class=\"line\">\ts.log.Infof(&quot;is_finished &#x3D; %+v&quot;, in.GetIsFinished())</span><br><span class=\"line\">\ts.log.Infof(&quot;is_deleted &#x3D; %+v&quot;, in.GetIsDelete())</span><br><span class=\"line\">\treturn &amp;v1.HelloFieldMaskResponse&#123;</span><br><span class=\"line\">\t\tFieldMask: in.GetFieldMask().Paths,</span><br><span class=\"line\">\t&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>此时接收到到FieldMask 字段为slice 类型，可判断字段是否在slice 里做响应逻辑处理。</p>\n<p>请求示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;task_id&quot;:1, &quot;is_finished&quot;:true,&quot;field_mask&quot;:&quot;isFinished&quot;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;fieldMask</span><br></pre></td></tr></table></div></figure>\n<p>注意 传参为camelCase 类型，即 生成到pb文件里，tag为 protobuf json定义：isFinished, isDelete。</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">type HelloFieldMaskRequest struct &#123;</span><br><span class=\"line\">\tstate         protoimpl.MessageState</span><br><span class=\"line\">\tsizeCache     protoimpl.SizeCache</span><br><span class=\"line\">\tunknownFields protoimpl.UnknownFields</span><br><span class=\"line\"></span><br><span class=\"line\">\tTaskId     int32                  &#96;protobuf:&quot;varint,1,opt,name&#x3D;task_id,json&#x3D;taskId,proto3&quot; json:&quot;task_id,omitempty&quot;&#96;</span><br><span class=\"line\">\tIsDelete   bool                   &#96;protobuf:&quot;varint,2,opt,name&#x3D;is_delete,json&#x3D;isDelete,proto3&quot; json:&quot;is_delete,omitempty&quot;&#96;</span><br><span class=\"line\">\tIsFinished bool                   &#96;protobuf:&quot;varint,3,opt,name&#x3D;is_finished,json&#x3D;isFinished,proto3&quot; json:&quot;is_finished,omitempty&quot;&#96;</span><br><span class=\"line\">\tFieldMask  *fieldmaskpb.FieldMask &#96;protobuf:&quot;bytes,4,opt,name&#x3D;field_mask,json&#x3D;fieldMask,proto3&quot; json:&quot;field_mask,omitempty&quot;&#96;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>另外如果field_mask传递多个字段，此时需要用“,” 分割：</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;task_id&quot;:1, &quot;is_finished&quot;:true,&quot;field_mask&quot;:&quot;isFinished, isDelete&quot;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;fieldMask</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Any-类型\"   >\n          <a href=\"#Any-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Any-类型\" class=\"headerlink\" title=\"Any 类型\"></a>Any 类型</h2>\n      <p><strong>官方定义：</strong></p>\n<blockquote>\n<p>The Any message type lets you use messages as embedded types without having their .proto definition. An Any contains an arbitrary serialized message as bytes, along with a URL that acts as a globally unique identifier for and resolves to that message’s type. To use the Any type, you need to import google/protobuf/any.proto.</p>\n</blockquote>\n<p>Any 消息类型允许您将消息用作嵌入类型，而无需它们的 .proto 定义。 Any 包含作为字节的任意序列化消息，以及充当全局唯一标识符并解析为该消息类型的 URL。 要使用 Any 类型，您需要导入 google/protobuf/any.proto。</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message ErrorStatus &#123;</span><br><span class=\"line\">  string message &#x3D; 1;</span><br><span class=\"line\">  repeated google.protobuf.Any details &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>给定消息类型的 URL 定义格式为：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">type.googleapis.com&#x2F;_packagename_._messagename_.</span><br></pre></td></tr></table></div></figure>\n<p>使用示例：</p>\n<p><strong>proto 定义</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax &#x3D; &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package helloworld.v1;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc AnyTypes (HelloAnyTypesRequest) returns (HelloAnyTypesResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;any&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloAnyTypesRequest &#123;</span><br><span class=\"line\">  string topic &#x3D; 1;</span><br><span class=\"line\">  google.protobuf.Any desc &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message DescType &#123;</span><br><span class=\"line\">  string value &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloAnyTypesResponse &#123;</span><br><span class=\"line\">  string topic &#x3D; 1;</span><br><span class=\"line\">  string desc &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p><strong>service 使用示例：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) AnyTypes(ctx context.Context, in *v1.HelloAnyTypesRequest) (*v1.HelloAnyTypesResponse, error)  &#123;</span><br><span class=\"line\">\ts.log.Infof(&quot;topic &#x3D; %+v&quot;, in.GetTopic())</span><br><span class=\"line\">\ts.log.Infof(&quot;desc &#x3D; %s&quot;, in.GetDesc().GetValue())</span><br><span class=\"line\">\treturn &amp;v1.HelloAnyTypesResponse&#123;</span><br><span class=\"line\">\t\tTopic: in.GetTopic(),</span><br><span class=\"line\">\t\tDesc: string(in.GetDesc().GetValue()),</span><br><span class=\"line\">\t&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>请求示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;topic&quot;:&quot;this is any type&quot;, &quot;desc&quot;:&#123;&quot;@type&quot;:&quot;type.googleapis.com&#x2F;helloworld.v1.DescType&quot;, &quot;value&quot;:&quot;this is any type desc&quot;&#125;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;any</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>@type 为 type.googleapis.com/ + package_name + message_name</li>\n<li>value 为message 的字段定义</li>\n</ul>\n\n        <h2 id=\"Timestamp-类型\"   >\n          <a href=\"#Timestamp-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Timestamp-类型\" class=\"headerlink\" title=\"Timestamp 类型\"></a>Timestamp 类型</h2>\n      <p>传递 ISO 时间对象，接收到之后，通过proto可以任意 转换时间对象方便处理：</p>\n<p><strong>proto 定义：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax &#x3D; &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc Times (HelloTsRequest) returns (HelloTsResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;ts&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloTsRequest &#123;</span><br><span class=\"line\">  google.protobuf.Timestamp time_begin &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloTsResponse &#123;</span><br><span class=\"line\">  int64 timestamp &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>service 使用示例：</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) Times(ctx context.Context, in *v1.HelloTsRequest) (*v1.HelloTsResponse, error)  &#123;</span><br><span class=\"line\">\ts.log.Infof(&quot;seconds &#x3D; %+v&quot;, in.GetTimeBegin().GetSeconds())</span><br><span class=\"line\">\ts.log.Infof(&quot;nano &#x3D; %s&quot;, in.GetTimeBegin().GetNanos())</span><br><span class=\"line\">\treturn &amp;v1.HelloTsResponse&#123;Timestamp: in.GetTimeBegin().GetSeconds()&#125;,nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>调用示例：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -H &quot;Content-Type:application&#x2F;json&quot; -d &#39;&#123;&quot;time_begin&quot;:&quot;2021-06-08T15:15:30.069Z&quot;&#125;&#39; 127.0.0.1:8000&#x2F;hello&#x2F;ts</span><br></pre></td></tr></table></div></figure>\n<p>注意传递的时间对象为UTC标准时间，否则转化获取到的时间戳不正确。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\" >javascript demo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"Struct-类型\"   >\n          <a href=\"#Struct-类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Struct-类型\" class=\"headerlink\" title=\"Struct 类型\"></a>Struct 类型</h2>\n      <p><strong>官方描述</strong></p>\n<blockquote>\n<p>Any JSON object</p>\n</blockquote>\n<p>任意 json 类型，当我们传递不固定的json数据时，此时无法对应到某个具体到proto message, struct类型就大显神通了。</p>\n<p>下面来看看具体到使用：</p>\n<p><strong>proto文件到定义：</strong></p>\n<p>需要导入 struct包：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax &#x3D; &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package helloworld.v1;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;google&#x2F;protobuf&#x2F;struct.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">rpc AnyJson (HelloStructRequest) returns (HelloStructResponse)  &#123;</span><br><span class=\"line\">    option (google.api.http) &#x3D; &#123;</span><br><span class=\"line\">      post: &quot;&#x2F;hello&#x2F;struct&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....省略其他代码</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloStructRequest &#123;</span><br><span class=\"line\">  google.protobuf.Struct json &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloStructResponse &#123;</span><br><span class=\"line\">  string detail &#x3D; 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>service 业务代码处理</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (s *GreeterService) AnyJson(ctx context.Context, in *v1.HelloStructRequest) (*v1.HelloStructResponse, error)  &#123;</span><br><span class=\"line\">\tmaps :&#x3D; in.GetJson().AsMap()</span><br><span class=\"line\">\ts.log.Infof(&quot;this is map[string]interface&#123;&#125;  &#x3D; %+v&quot;, maps)</span><br><span class=\"line\">\tfor key, value :&#x3D; range in.GetJson().GetFields() &#123;</span><br><span class=\"line\">\t\ts.log.Infof(&quot;maps key &#x3D; %+v&quot;, key)</span><br><span class=\"line\">\t\tswitch value.Kind.(type) &#123;</span><br><span class=\"line\">\t\tcase *structpb.Value_NumberValue:</span><br><span class=\"line\">\t\t\ts.log.Infof(&quot;maps value is number &#x3D; %+v&quot;, value.GetNumberValue())</span><br><span class=\"line\">\t\tcase *structpb.Value_StringValue:</span><br><span class=\"line\">\t\t\ts.log.Infof(&quot;maps value is number &#x3D; %+v&quot;, value.GetStringValue())</span><br><span class=\"line\">\t\tcase *structpb.Value_BoolValue:</span><br><span class=\"line\">\t\t\ts.log.Infof(&quot;maps value is number &#x3D; %+v&quot;, value.GetBoolValue())</span><br><span class=\"line\">\t\tdefault:</span><br><span class=\"line\">\t\t\ts.log.Infof(&quot;maps value is other type &#x3D; %+v&quot;, value.AsInterface())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbts, _ :&#x3D; json.Marshal(maps)</span><br><span class=\"line\">\treturn &amp;v1.HelloStructResponse&#123;</span><br><span class=\"line\">\t\tDetail: string(bts),</span><br><span class=\"line\">\t&#125;,nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>值的类型，可通过 structpb 包下定义的枚举类型来判断：structpb.Value_StringValue，Value_NumberValue， Value_BoolValue， structpb.Value_ListValue， structpb.Value_StructValue， structpb.Value_NullValue等等，具体枚举值，可查看structpb包源码。</p>\n\n        <h2 id=\"代码地址\"   >\n          <a href=\"#代码地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h2>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/luckylsx/kratos-proto-demo\" >https://github.com/luckylsx/kratos-proto-demo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"参考\"   >\n          <a href=\"#参考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developers.google.com/protocol-buffers/docs/proto3\" >https://developers.google.com/protocol-buffers/docs/proto3</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["rpc"],"tags":["grpc","kratos","Protocal Buffers"]},{"title":"vscode搭建golang开发环境","url":"/2021/06/10/vscode%E6%90%AD%E5%BB%BAgolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","content":"<p>在 vscode 的使用过程中,自己也是从小白到慢慢熟练vscode的日常开发，现在已经很少使用goland 等IDE，平时基本都在使用vscode。本篇文章主要记录自己vscode等一些探索，方便大家快速使用vscode做golang 开发。</p>\n\n        <h2 id=\"golang-插件安装\"   >\n          <a href=\"#golang-插件安装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#golang-插件安装\" class=\"headerlink\" title=\"golang 插件安装\"></a>golang 插件安装</h2>\n      <a id=\"more\"></a>\n\n<p>首先需要安装golang 相关插件包，Mac 环境下 按快捷键 command+shift+p（windows 环境下 ctrl+shift+p）打开控制面板，输入 “GO: Install/Update” 选中 “GO: Install/Update Tools” 点击进入，全选，点击ok 自动安装。主意此方法部分包需要科学上网，否则会出现安装失败问题。</p>\n<p><strong>vscode 配置科学上网 proxy</strong></p>\n<p>进入设置（Settings），搜索 “Http: Proxy”，配置代理即可。</p>\n<p>如果无法科学上网，安装失败，可更改go mod 走国内代理即可，详细方法，可参照此文：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blog.csdn.net/qq_41065919/article/details/107710144\" >https://blog.csdn.net/qq_41065919/article/details/107710144</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"code-runner-运行项目\"   >\n          <a href=\"#code-runner-运行项目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#code-runner-运行项目\" class=\"headerlink\" title=\"code-runner 运行项目\"></a>code-runner 运行项目</h2>\n      <p>Code Runner支持了 Node.js, Python, C++, Java, PHP, Perl, Ruby, Go等超过40种的语言。下面，我们就来看看如何来玩转Code Runner，提高你的效率。</p>\n<p>首先需要安装<strong>code-runner</strong>插件，在插件库搜索 code-runner，并安装。</p>\n<p><strong>运行golang的几种情况</strong></p>\n\n        <h3 id=\"单文件运行和无需指定配置文件项目\"   >\n          <a href=\"#单文件运行和无需指定配置文件项目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#单文件运行和无需指定配置文件项目\" class=\"headerlink\" title=\"单文件运行和无需指定配置文件项目\"></a>单文件运行和无需指定配置文件项目</h3>\n      <p>直接找到main文件所在目录，点击main文件，无需任何配置，直接点击vscode右上角运行按钮即可直接运行。</p>\n\n        <h3 id=\"运行需要指定配置的项目\"   >\n          <a href=\"#运行需要指定配置的项目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#运行需要指定配置的项目\" class=\"headerlink\" title=\"运行需要指定配置的项目\"></a>运行需要指定配置的项目</h3>\n      <p>需要在项目目录下添加.vscode的文件夹，并添加settings.json配置文件，添加配置信息如下所示：</p>\n\n        <h4 id=\"相对路径配置\"   >\n          <a href=\"#相对路径配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#相对路径配置\" class=\"headerlink\" title=\"相对路径配置\"></a>相对路径配置</h4>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;code-runner.executorMap&quot;: &#123;</span><br><span class=\"line\">        &quot;go&quot;: &quot;cd  $dir &amp;&amp; go run . -conf ..&#x2F;..&#x2F;configs&quot;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>可指定如上配置：$dir 为系统变量，当打开main文件之后，点击运行按钮时，vscode 会自动进入main 文件所在目录，并根据 -conf 指定的配置文件，启动项目。</p>\n<p>此方式也适合多项目启动，如果我们工作区下面有多个项目，每个服务都需要启动，这种方式也比较方便，只是每次启动服务时，都需要打开相应的main文件。</p>\n<p>这种相对路径的配置方法每次启动都需要打开相应的main文件，多次一举，也会很不方便，下面的绝对目录方式就可以完美解决。单不适合多服务都需要启动模式。</p>\n\n        <h4 id=\"绝对路径配置\"   >\n          <a href=\"#绝对路径配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#绝对路径配置\" class=\"headerlink\" title=\"绝对路径配置\"></a>绝对路径配置</h4>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;code-runner.executorMap&quot;: &#123;</span><br><span class=\"line\">        &quot;go&quot;: &quot;cd  &#x2F;Users&#x2F;limuzi&#x2F;go&#x2F;src&#x2F;&#123;grogram&#125;&#x2F;cmd&#x2F;graphql-layout &amp;&amp; go run . -conf ..&#x2F;..&#x2F;configs&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;code-runner.fileDirectoryAsCwd&quot;: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>grogram 替换成自己真实项目名称即可。此种方式比较简单，在打开任意go文件时，都可直接点击右上角运行按钮，即可启动程序运行。</p>\n\n        <h2 id=\"debug\"   >\n          <a href=\"#debug\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2>\n      \n        <h3 id=\"单main文件\"   >\n          <a href=\"#单main文件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#单main文件\" class=\"headerlink\" title=\"单main文件\"></a>单main文件</h3>\n      <p>可直接点击 Run and Debug 按钮，开启调试</p>\n<p><strong>停止运行：</strong></p>\n<ul>\n<li>控制面板：输入 Stop Code Run 点击即可</li>\n<li>快捷键 ctrl+option+M 停止运行</li>\n</ul>\n\n        <h3 id=\"调试项目\"   >\n          <a href=\"#调试项目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#调试项目\" class=\"headerlink\" title=\"调试项目\"></a>调试项目</h3>\n      <p>首先需要安装 div依赖包</p>\n<p>安装方式：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get -u github.com&#x2F;go-delve&#x2F;delve&#x2F;cmd&#x2F;dlv</span><br></pre></td></tr></table></div></figure>\n<p>调试项目是，需要在项目目录.vscode文件夹下，添加launch.json 配置。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class=\"line\">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class=\"line\">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class=\"line\">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">    &quot;configurations&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;debug order&quot;,</span><br><span class=\"line\">            &quot;type&quot;: &quot;go&quot;,</span><br><span class=\"line\">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">            &quot;mode&quot;: &quot;debug&quot;,</span><br><span class=\"line\">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;app&#x2F;order&#x2F;cmd&#x2F;server&quot;,</span><br><span class=\"line\">            &quot;cwd&quot;: &quot;.&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [&quot;-conf&quot;, &quot;$&#123;workspaceFolder&#125;&#x2F;app&#x2F;order&#x2F;configs&#x2F;config.yaml&quot;],</span><br><span class=\"line\">            &quot;env&quot;: &#123;</span><br><span class=\"line\">                &quot;RUN_ENV&quot;:&quot;dev&quot;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;dlvLoadConfig&quot;: &#123;</span><br><span class=\"line\">                &quot;followPointers&quot;: true,</span><br><span class=\"line\">                &quot;maxVariableRecurse&quot;: 1,</span><br><span class=\"line\">                &quot;maxStringLen&quot;: 5000,</span><br><span class=\"line\">                &quot;maxArrayValues&quot;: 64,</span><br><span class=\"line\">                &quot;maxStructFields&quot;: -1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;debug admin&quot;,</span><br><span class=\"line\">            &quot;type&quot;: &quot;go&quot;,</span><br><span class=\"line\">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">            &quot;mode&quot;: &quot;debug&quot;,</span><br><span class=\"line\">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;app&#x2F;admin&#x2F;cmd&#x2F;server&quot;,</span><br><span class=\"line\">            &quot;cwd&quot;: &quot;.&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [&quot;-conf&quot;, &quot;$&#123;workspaceFolder&#125;&#x2F;app&#x2F;admin&#x2F;configs&#x2F;config.yaml&quot;],</span><br><span class=\"line\">            &quot;env&quot;: &#123;</span><br><span class=\"line\">                &quot;RUN_ENV&quot;:&quot;dev&quot;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;dlvLoadConfig&quot;: &#123;</span><br><span class=\"line\">                &quot;followPointers&quot;: true,</span><br><span class=\"line\">                &quot;maxVariableRecurse&quot;: 1,</span><br><span class=\"line\">                &quot;maxStringLen&quot;: 5000,</span><br><span class=\"line\">                &quot;maxArrayValues&quot;: 64,</span><br><span class=\"line\">                &quot;maxStructFields&quot;: -1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>${workspaceFolder}: 工作区根目录</li>\n</ul>\n<p>相关属性介绍：</p>\n<ul>\n<li>name: 调试界面下拉选择项的名称</li>\n<li>type: 设置为go无需改动，是 vscode 用于计算调试代码需要用哪个扩展</li>\n<li>mode: 可以设置为 auto, debug, remote, test, exec 中的一个</li>\n<li>program: 调试程序的路径（绝对路径）</li>\n<li>env: 调试时使用的环境变量。例如:{ “ENVNAME”: “ENVVALUE” }</li>\n<li>envFile: 包含环境变量文件的绝对路径，在 env 中设置的属性会覆盖 envFile 中的配置</li>\n<li>args: 传给正在调试程序命令行参数数组 可指定配置文件 如：[“-conf”, “${workspaceFolder}/app/admin/configs/config.yaml”]</li>\n<li>showLog: 布尔值，是否将调试信息输出</li>\n<li>logOutput: 配置调试输出的组件（debugger, gdbwire, lldbout, debuglineerr, rpc）,使用,分隔， showLog 设置为 true 时，此项配置生效</li>\n<li>buildFlags: 构建 go 程序时传给 go 编译器的标志</li>\n<li>remotePath: 远程调试程序的绝对路径，当 mode 设置为 remote 时有效</li>\n<li>dlvLoadConfig: 调试打印信息过长无法显示全部时，可添加此配置</li>\n</ul>\n<p>dlvLoadConfig 相关说明</p>\n<ul>\n<li>maxStringLen: 显示的字符串最大长度</li>\n</ul>\n\n        <h2 id=\"提高开发效率的小方法：\"   >\n          <a href=\"#提高开发效率的小方法：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#提高开发效率的小方法：\" class=\"headerlink\" title=\"提高开发效率的小方法：\"></a>提高开发效率的小方法：</h2>\n      \n        <h3 id=\"变量命名方式转换\"   >\n          <a href=\"#变量命名方式转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#变量命名方式转换\" class=\"headerlink\" title=\"变量命名方式转换\"></a>变量命名方式转换</h3>\n      <p>安装 Change-case插件</p>\n<p>打开控制面板, 输入change 即可快速将变量转换为选择类型：</p>\n<ul>\n<li>Change Case snake: 转换为下划线类型</li>\n<li>Change Case camel: 转换为驼峰命名<br>….</li>\n</ul>\n<p>也可以选择 Change Case Commands 来选择需要的类型。</p>\n\n        <h3 id=\"struct-快速填充\"   >\n          <a href=\"#struct-快速填充\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#struct-快速填充\" class=\"headerlink\" title=\"struct 快速填充\"></a>struct 快速填充</h3>\n      <p>mac 环境下 command+. 快速填充struct</p>\n\n        <h3 id=\"struct-快速添加tag\"   >\n          <a href=\"#struct-快速添加tag\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#struct-快速添加tag\" class=\"headerlink\" title=\"struct 快速添加tag\"></a>struct 快速添加tag</h3>\n      <p>mac 环境下 command+shift+p 打开控制面板，输入 Add Tags,选择 Add Tags To Struct Fields()</p>\n\n        <h3 id=\"struct-快速删除tag\"   >\n          <a href=\"#struct-快速删除tag\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#struct-快速删除tag\" class=\"headerlink\" title=\"struct 快速删除tag\"></a>struct 快速删除tag</h3>\n      <p>mac 环境下 command+shift+p 打开控制面板，输入 Remove Tag,选择 remove Tags From Struct Fields</p>\n\n        <h3 id=\"自动生成单元测试\"   >\n          <a href=\"#自动生成单元测试\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#自动生成单元测试\" class=\"headerlink\" title=\"自动生成单元测试\"></a>自动生成单元测试</h3>\n      <p>mac 环境下 command+shift+p 打开控制面板，输入 Generate Unit Tests,选择 Generate Unit Tests For File;即可自动为打开的文件生成单元测试。</p>\n\n        <h3 id=\"快速实现接口实现\"   >\n          <a href=\"#快速实现接口实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#快速实现接口实现\" class=\"headerlink\" title=\"快速实现接口实现\"></a>快速实现接口实现</h3>\n      <ul>\n<li>impl 命令</li>\n</ul>\n<p>使用方法：</p>\n<p>进入到类型实现所在目录</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">impl &#39;r *queryResolver&#39; generated.QueryResolver</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>r 为类型接收到形参</li>\n<li>queryResolver 为类型名</li>\n<li>generated.QueryResolver 接口 interface, generated 为包名，QueryResolver 为 interface 名称</li>\n</ul>\n<p>方法会自动生成到终端：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (r *queryResolver) GetOrder(ctx context.Context, id int) (*common.OrderInfo, error) &#123;</span><br><span class=\"line\">        panic(&quot;not implemented&quot;) &#x2F;&#x2F; TODO: Implement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (r *queryResolver) GetAddress(ctx context.Context, id int) (*common.AddressInfo, error) &#123;</span><br><span class=\"line\">        panic(&quot;not implemented&quot;) &#x2F;&#x2F; TODO: Implement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"好用的插件\"   >\n          <a href=\"#好用的插件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#好用的插件\" class=\"headerlink\" title=\"好用的插件\"></a>好用的插件</h2>\n      <p>个人在使用过程中总结了以下好用的插件：</p>\n<ul>\n<li>Change-case 变量命名格式转换</li>\n<li>Remote-ssh ssh客户端</li>\n<li>Gitlens</li>\n<li>Git Graph</li>\n<li>Git History</li>\n<li>Todo Tree</li>\n<li>Docker</li>\n<li>Live Share 很好的一个团队协作工具</li>\n<li>MySQL cweijan.vscode-mysql-client2 好用的数据库客户端</li>\n<li>CodeStream: GitHub, GitLab, Bitbucket PRs and Code Review 协作工具</li>\n</ul>\n","categories":["golang"],"tags":["golang","vscode"]},{"title":"leetcode-2079.LRU缓存","url":"/2021/06/15/leetcode-2079.LRU%E7%BC%93%E5%AD%98/","content":"<p><strong>题目</strong></p>\n<p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p>\n<p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>\n<a id=\"more\"></a>\n\n<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class=\"line\"></span><br><span class=\"line\">cache.put(1, 1);</span><br><span class=\"line\">cache.put(2, 2);</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class=\"line\">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class=\"line\">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class=\"line\">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></div></figure>\n<p>golang 题解：</p>\n<p>通过内置 container/list包 双向链表实现：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">package lru</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;container&#x2F;list&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">type LRUCache struct &#123;</span><br><span class=\"line\">\tCap int</span><br><span class=\"line\">\tKeys map[int]*list.Element</span><br><span class=\"line\">\tList *list.List</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Pairs struct &#123;</span><br><span class=\"line\">\tK, V int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Constructor(capacity int) LRUCache &#123;</span><br><span class=\"line\">\treturn LRUCache&#123;</span><br><span class=\"line\">\t\tCap:  capacity,</span><br><span class=\"line\">\t\tKeys: make(map[int]*list.Element),</span><br><span class=\"line\">\t\tList: list.New(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (this *LRUCache) Get(key int) int &#123;</span><br><span class=\"line\">\tif el , ok :&#x3D; this.Keys[key]; ok &#123;</span><br><span class=\"line\">\t\tthis.List.MoveToFront(el)</span><br><span class=\"line\">\t\treturn el.Value.(Pairs).V</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn -1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func (this *LRUCache) Put(key int, value int)  &#123;</span><br><span class=\"line\">\tif el, ok :&#x3D; this.Keys[key]; ok &#123;</span><br><span class=\"line\">\t\tel.Value &#x3D; Pairs&#123;</span><br><span class=\"line\">\t\t\tK: key,</span><br><span class=\"line\">\t\t\tV: value,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis.List.PushFront(el)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tel &#x3D; this.List.PushFront(Pairs&#123;</span><br><span class=\"line\">\t\t\tK: key,</span><br><span class=\"line\">\t\t\tV: value,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tthis.Keys[key] &#x3D; el</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif this.List.Len() &gt; this.Cap &#123;</span><br><span class=\"line\">\t\tel :&#x3D; this.List.Back()</span><br><span class=\"line\">\t\tthis.List.Remove(el)</span><br><span class=\"line\">\t\tdelete(this.Keys, el.Value.(Pairs).K)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>来源：力扣（LeetCode）</p>\n<p>链接：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://leetcode-cn.com/problems/lru-cache-lcci\" >https://leetcode-cn.com/problems/lru-cache-lcci</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n","categories":["golang"],"tags":["algorithm"]},{"title":"cgroups隔离与限制","url":"/2021/06/21/cgroups%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/","content":"\n        <h3 id=\"cgroups介绍\"   >\n          <a href=\"#cgroups介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#cgroups介绍\" class=\"headerlink\" title=\"cgroups介绍\"></a>cgroups介绍</h3>\n      <p>cgroups(Control Groups) 是linux 内核提供的一种为系统资源进程有效隔离和限制的一种手段。它可以有效的限制资源使用的cpu,内存及物理设备，如：磁盘等做精准限制。防止某一进程资源占用过大，导致整个系统物理资源耗尽，影响其他进程的运行。</p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"cgroups子系统\"   >\n          <a href=\"#cgroups子系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#cgroups子系统\" class=\"headerlink\" title=\"cgroups子系统\"></a>cgroups子系统</h3>\n      <p>cgroups为每种可以控制的资源定义了一个子系统。典型的子系统介绍如下：</p>\n<ul>\n<li>cpu 子系统，主要限制进程的 cpu 使用率。</li>\n<li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>\n<li>cpuset 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li>\n<li>memory 子系统，可以限制进程的 memory 使用量。</li>\n<li>blkio 子系统，可以限制进程的块设备 io。</li>\n<li>devices 子系统，可以控制进程能够访问某些设备。</li>\n<li>net_cls 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li>\n<li>freezer 子系统，可以挂起或者恢复 cgroups 中的进程。<br>ns 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。</li>\n</ul>\n<p>这里面每一个子系统都需要与内核的其他模块配合来完成资源的控制，比如对 cpu 资源的限制是通过进程调度模块根据 cpu 子系统的配置来完成的；对内存资源的限制则是内存模块根据 memory 子系统的配置来完成的，而对网络数据包的控制则需要 Traffic Control 子系统来配合完成。</p>\n<p><em>cgroup</em> 将一组任务与一组参数相关联或更多子系统。</p>\n<p><em>子系统</em>是一个利用任务分组的模块cgroups 提供的设施来处理任务组具体方式。一个子系统通常是一个“资源控制器”，它调度资源或应用每个 cgroup 限制，但它可能是任何想要对一组进程采取行动的东西，例如一种虚拟化子系统。</p>\n<p>一个 <em>hierarchy</em> 是一组排列在树中的 cgroups，使得系统中的每一个任务都在其中的一个 cgroup 中层次结构和一组子系统；每个子系统都有系统特定的状态附加到层次结构中的每个 cgroup。每个层次都有与之关联的 cgroup 虚拟文件系统的实例。</p>\n\n        <h3 id=\"cgroups-层级结构（Hierarchy）\"   >\n          <a href=\"#cgroups-层级结构（Hierarchy）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#cgroups-层级结构（Hierarchy）\" class=\"headerlink\" title=\"cgroups 层级结构（Hierarchy）\"></a>cgroups 层级结构（Hierarchy）</h3>\n      <p>内核使用 cgroup 结构体来表示一个 control group 对某一个或者某几个 cgroups 子系统的资源限制。cgroup 结构体可以组织成一颗树的形式，每一棵cgroup 结构体组成的树称之为一个 cgroups 层级结构。cgroups层级结构可以 attach 一个或者几个 cgroups 子系统，当前层级结构可以对其 attach 的 cgroups 子系统进行资源的限制。每一个 cgroups 子系统只能被 attach 到一个 cpu 层级结构中。</p>\n<img src=\"/images/Istio/cgroups/cgroups.png\" art=\"cgroups\" width=\"500px\">\n\n<p>比如上图表示两个cgroups层级结构，每一个层级结构中是一颗树形结构，树的每一个节点是一个 cgroup 结构体（比如cpu_cgrp, memory_cgrp)。第一个 cgroups 层级结构 attach 了 cpu 子系统和 cpuacct 子系统， 当前 cgroups 层级结构中的 cgroup 结构体就可以对 cpu 的资源进行限制，并且对进程的 cpu 使用情况进行统计。 第二个 cgroups 层级结构 attach 了 memory 子系统，当前 cgroups 层级结构中的 cgroup 结构体就可以对 memory 的资源进行限制。</p>\n<p>在每一个 cgroups 层级结构中，每一个节点（cgroup 结构体）可以设置对资源不同的限制权重。比如上图中 cgrp1 组中的进程可以使用60%的 cpu 时间片，而 cgrp2 组中的进程可以使用20%的 cpu 时间片。</p>\n\n        <h3 id=\"未使用cgroup限制后果\"   >\n          <a href=\"#未使用cgroup限制后果\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#未使用cgroup限制后果\" class=\"headerlink\" title=\"未使用cgroup限制后果\"></a>未使用cgroup限制后果</h3>\n      <p><strong>以下所有操作都是在虚拟机 centos8里面进行操作实验</strong></p>\n<p>我们在终端运行一下死循环，并top查看。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# while : ; do : ;done</span><br><span class=\"line\">[1] 10179</span><br></pre></td></tr></table></div></figure>\n<p>牢记该进程id，下面进行进程隔离是需要用到。也可通过ps查看。</p>\n<img src=\"/images/Istio/cgroups/cgroups-unlimit.png\" art=\"cgroups\" width=\"500px\">\n\n<p>此时cpu爆满，严重影响其他进程。</p>\n<p>我们如何将该进程进行有效的资源限制来保护我们系统上的其他资源呢？请看下面操作</p>\n\n        <h3 id=\"linux-进程隔离\"   >\n          <a href=\"#linux-进程隔离\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#linux-进程隔离\" class=\"headerlink\" title=\"linux 进程隔离\"></a>linux 进程隔离</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# cd &#x2F;sys&#x2F;fs&#x2F;cgroups&#x2F;cpu</span><br><span class=\"line\">[root@localhost cpu]# mkdir my-app</span><br></pre></td></tr></table></div></figure>\n<p>如图：</p>\n<img src=\"/images/Istio/cgroups/shell-loop.png\" art=\"cgroups\" width=\"500px\">\n\n<p>查看我们新建的my-app 控制组限制：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost cpu]# cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us </span><br><span class=\"line\">-1</span><br><span class=\"line\">[root@localhost cpu]# cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_period_us </span><br><span class=\"line\">100000</span><br></pre></td></tr></table></div></figure>\n<p>my-app 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）。</p>\n<p>接下来，我们可以通过修改这些文件的内容来设置限制。比如，向 my-app 组里的 cfs_quota 文件写入 20 ms（20000 us）：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost cpu]# echo 20000 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;my-app&#x2F;cpu.cfs_quota_us</span><br></pre></td></tr></table></div></figure>\n<p>它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。</p>\n<p>接下来，我们把被限制的进程的 PID 写入 my-app 组里的 tasks 文件，上面的设置就会对该进程生效了：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost cpu]# echo 10179 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;my-app&#x2F;tasks </span><br></pre></td></tr></table></div></figure>\n<p>此时我们在通过top 指令查看资源消耗：</p>\n<img src=\"/images/Istio/cgroups/shell-cgroups.png\" art=\"cgroups\" width=\"500px\">\n\n\n        <h3 id=\"docker-容器中的隔离使用\"   >\n          <a href=\"#docker-容器中的隔离使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#docker-容器中的隔离使用\" class=\"headerlink\" title=\"docker 容器中的隔离使用\"></a>docker 容器中的隔离使用</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it --cpu-period&#x3D;100000 --cpu-quota&#x3D;20000 ubuntu bin&#x2F;bash</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>–cpu-period cpu运行时间</li>\n<li>–cpu-quota 分配到到cpu运行时间</li>\n</ul>\n<p>上面到示例意味者 运行 100ms，只能分配实际运行时间为 20ms,也就意味只占总cpu的20%。</p>\n<p>运行容器之后，在交互洁面输入下面代码测试：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# while : ; do : ;done</span><br></pre></td></tr></table></div></figure>\n<p>此时查看top命令，cpu 只占到了 20%,达到了有效的限制。</p>\n<img src=\"/images/Istio/cgroups/cgroup-limit.png\" art=\"cgroups\" width=\"500px\">\n\n\n\n\n\n        <h3 id=\"删除限制组\"   >\n          <a href=\"#删除限制组\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#删除限制组\" class=\"headerlink\" title=\"删除限制组\"></a>删除限制组</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">rmdir my-app</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"未完待续\"   >\n          <a href=\"#未完待续\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h3>\n      <p>参考：</p>\n<ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt\" >https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/sammyliu/p/5886833.html\" >https://www.cnblogs.com/sammyliu/p/5886833.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://tech.meituan.com/2015/03/31/cgroups.html\" >https://tech.meituan.com/2015/03/31/cgroups.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["Istio"],"tags":["linux","container"]},{"title":"redis分布式琐的正确姿势","url":"/2021/06/26/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/","content":"\n        <h2 id=\"redis锁使用的正确姿势\"   >\n          <a href=\"#redis锁使用的正确姿势\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#redis锁使用的正确姿势\" class=\"headerlink\" title=\"redis锁使用的正确姿势\"></a>redis锁使用的正确姿势</h2>\n      <p>可靠的分布式锁，要具备以下几个特性</p>\n<ol>\n<li>互斥性。（在任意时刻，只有一个客户端能持有锁）</li>\n<li>不会发生死锁。(即使有一个客户端在持有琐的期间崩溃而没有主动释放锁，也能保证后续其他客户端能加锁)</li>\n<li>具有容错性。（只要大部分的Redis正常运行，客户端就可以加锁和解锁）<a id=\"more\"></a></li>\n<li>解铃还需系铃人。（加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了）</li>\n<li>锁不能自己失效。（正常执行过程中锁不能因为某些原因自己失效，会造成多个程序运行同一个任务）</li>\n</ol>\n\n        <h3 id=\"错误案例\"   >\n          <a href=\"#错误案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#错误案例\" class=\"headerlink\" title=\"错误案例\"></a>错误案例</h3>\n      \n        <h4 id=\"setNx\"   >\n          <a href=\"#setNx\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#setNx\" class=\"headerlink\" title=\"setNx\"></a>setNx</h4>\n      <p>SETNX key value</p>\n<p>redis&gt; SETNX job “programmer”    # job 设置成功</p>\n<p>(integer) 1</p>\n<p><strong>条件分析</strong></p>\n<p>保证了redis里只有唯一的key存在</p>\n<p>有效时间避免了死锁的发生</p>\n<p>但不满足3，4，5特点。</p>\n\n        <h4 id=\"采用Lua脚本实现\"   >\n          <a href=\"#采用Lua脚本实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#采用Lua脚本实现\" class=\"headerlink\" title=\"采用Lua脚本实现\"></a>采用Lua脚本实现</h4>\n      <p>golang实现</p>\n<figure class=\"highlight golang\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/go-kratos/kratos/v2/log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t_LockDistributedLua = <span class=\"string\">&quot;local v;&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;v = redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]);&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;if tonumber(v) == 1 then\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;    redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2])\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;end\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;return v&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t_UnLockDistributedLua = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1]\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;then\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;    return redis.call(&#x27;del&#x27;,KEYS[1])\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;else\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;    return 0\\n&quot;</span> +</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;end&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t_DistributedTimeOut = <span class=\"number\">4</span></span><br><span class=\"line\">\t_DistributedSuccess = <span class=\"number\">1</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t_LockDistributedLuaScript   = redis.NewScript(_LockDistributedLua)</span><br><span class=\"line\">\t_UnLockDistributedLuaScript = redis.NewScript(_UnLockDistributedLua)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Option <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tAddrs        []<span class=\"keyword\">string</span></span><br><span class=\"line\">\tPwd          <span class=\"keyword\">string</span></span><br><span class=\"line\">\tDB           <span class=\"keyword\">int</span></span><br><span class=\"line\">\tDialTimeout  time.Duration</span><br><span class=\"line\">\tWriteTimeout time.Duration</span><br><span class=\"line\">\tReadTimeout  time.Duration</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Redis <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcluster     *redis.ClusterClient</span><br><span class=\"line\">\tsingle      *redis.Client</span><br><span class=\"line\">\tclusterMode <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tmutex       *sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRedis</span><span class=\"params\">(c *Option)</span> *<span class=\"title\">Redis</span></span> &#123;</span><br><span class=\"line\">\tlog := log.NewHelper(log.DefaultLogger)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(c.Addrs) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr := &amp;Redis&#123;&#125;</span><br><span class=\"line\">\tr.log = log</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(c.Addrs) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\tr.single = redis.NewClient(</span><br><span class=\"line\">\t\t\t&amp;redis.Options&#123;</span><br><span class=\"line\">\t\t\t\tAddr:         c.Addrs[<span class=\"number\">0</span>], <span class=\"comment\">// use default Addr</span></span><br><span class=\"line\">\t\t\t\tPassword:     c.Pwd,      <span class=\"comment\">// no password set</span></span><br><span class=\"line\">\t\t\t\tDB:           c.DB,       <span class=\"comment\">// use default DB</span></span><br><span class=\"line\">\t\t\t\tDialTimeout:  c.DialTimeout,</span><br><span class=\"line\">\t\t\t\tReadTimeout:  c.ReadTimeout,</span><br><span class=\"line\">\t\t\t\tWriteTimeout: c.WriteTimeout,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := r.single.Ping(context.Background()).Err(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tr.log.Errorf(err.Error())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tr.single.Do(context.Background(), <span class=\"string\">&quot;CONFIG&quot;</span>, <span class=\"string\">&quot;SET&quot;</span>, <span class=\"string\">&quot;notify-keyspace-events&quot;</span>, <span class=\"string\">&quot;AKE&quot;</span>)</span><br><span class=\"line\">\t\tr.clusterMode = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\tr.mutex = <span class=\"built_in\">new</span>(sync.Mutex)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.cluster = redis.NewClusterClient(</span><br><span class=\"line\">\t\t&amp;redis.ClusterOptions&#123;</span><br><span class=\"line\">\t\t\tAddrs:        c.Addrs,</span><br><span class=\"line\">\t\t\tPassword:     c.Pwd,</span><br><span class=\"line\">\t\t\tDialTimeout:  c.DialTimeout,</span><br><span class=\"line\">\t\t\tReadTimeout:  c.ReadTimeout,</span><br><span class=\"line\">\t\t\tWriteTimeout: c.WriteTimeout,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := r.cluster.Ping(context.Background()).Err(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tr.log.Errorf(<span class=\"string\">&quot;cluster init failed, error : &quot;</span>, err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr.cluster.Do(context.Background(), <span class=\"string\">&quot;CONFIG&quot;</span>, <span class=\"string\">&quot;SET&quot;</span>, <span class=\"string\">&quot;notify-keyspace-events&quot;</span>, <span class=\"string\">&quot;AKE&quot;</span>)</span><br><span class=\"line\">\tr.clusterMode = <span class=\"literal\">true</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Redis)</span> <span class=\"title\">Run</span><span class=\"params\">(ctx context.Context, script *redis.Script, keys []<span class=\"keyword\">string</span>, argv ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">\tr.mutex.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> r.mutex.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.clusterMode &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> script.Run(ctx, r.cluster, keys, argv...).Val()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> script.Run(ctx, r.single, keys, argv...).Val()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Redis)</span> <span class=\"title\">TryGetDistributedLock</span><span class=\"params\">(ctx context.Context, key <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> res <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.clusterMode &#123;</span><br><span class=\"line\">\t\tres = _LockDistributedLuaScript.Run(ctx, r.cluster, []<span class=\"keyword\">string</span>&#123;key&#125;, <span class=\"string\">&quot;_&quot;</span>, _DistributedTimeOut).Val()</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tres = _LockDistributedLuaScript.Run(ctx, r.single, []<span class=\"keyword\">string</span>&#123;key&#125;, <span class=\"string\">&quot;_&quot;</span>, _DistributedTimeOut).Val()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res.(<span class=\"keyword\">int64</span>) == _DistributedSuccess</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Redis)</span> <span class=\"title\">TryGetDistributedLockWithTimeOut</span><span class=\"params\">(ctx context.Context, key <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\tend := duration.Milliseconds()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> getNowMillisecond() &lt;= end &#123;</span><br><span class=\"line\">\t\tsuc := r.TryGetDistributedLock(ctx, key)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> suc &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsleepMillisecond(<span class=\"number\">80</span> + <span class=\"keyword\">int64</span>(rand.Int31n(<span class=\"number\">30</span>)))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Redis)</span> <span class=\"title\">ReleaseDistributedLock</span><span class=\"params\">(ctx context.Context, key <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\tr.mutex.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> r.mutex.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> res <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.clusterMode &#123;</span><br><span class=\"line\">\t\tres = _UnLockDistributedLuaScript.Run(ctx, r.cluster, []<span class=\"keyword\">string</span>&#123;key&#125;, <span class=\"string\">&quot;_&quot;</span>).Val()</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tres = _UnLockDistributedLuaScript.Run(ctx, r.single, []<span class=\"keyword\">string</span>&#123;key&#125;, <span class=\"string\">&quot;_&quot;</span>).Val()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res.(<span class=\"keyword\">int64</span>) == _DistributedSuccess &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"参考\"   >\n          <a href=\"#参考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.bilibili.com/video/BV1r5411V7Sb\" >https://www.bilibili.com/video/BV1r5411V7Sb</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["redis"],"tags":["redis"]},{"title":"grpc版本控制","url":"/2021/07/02/grpc%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","content":"<p>grpc服务更改时，应考虑一下内容：</p>\n<ul>\n<li>更改会对客户端造成如何影响</li>\n<li>应实现支持更改对版本控制策略</li>\n</ul>\n\n        <h3 id=\"向后兼容性\"   >\n          <a href=\"#向后兼容性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#向后兼容性\" class=\"headerlink\" title=\"向后兼容性\"></a>向后兼容性</h3>\n      <a id=\"more\"></a>\n\n<p>grpc协议旨在支持随时间变化的服务。通常grpc服务和方法会不中断的新增内容。非中断性变更允许现有客户端继续工作而不做任何更改。更改或删除grpc服务是中断性变更。grpc服务发生中断性变更时，必须更新和重新部署使用该服务的客户端。</p>\n<p>对服务进行非中断性变更有一下好处：</p>\n<ul>\n<li>现有客户端继续运行</li>\n<li>避免向客户端通知中断性变更并进行更新</li>\n<li>只需要记录和维护服务对一个版本</li>\n</ul>\n\n        <h3 id=\"非重大变化\"   >\n          <a href=\"#非重大变化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#非重大变化\" class=\"headerlink\" title=\"非重大变化\"></a>非重大变化</h3>\n      <p>在grpc协议级别和二进制级别，这些变更不会中断。</p>\n<ul>\n<li>添加新服务</li>\n<li>向新服务添加新方法</li>\n<li>将字段添加到请求消息 - 添加到请求消息的字段将在服务器上通过默认值（若未设置）进行反序列化。若要实现非中断性变更，当新字段不是由旧客户端设置时，服务必须成功。</li>\n<li>将字段添加到响应消息 - 添加到响应消息的字段将反序列化到客户端上消息的未知字段集合中</li>\n<li>向枚举添加新值 - 枚举被序列化为数值。新的枚举在客户端反序列化为没有枚举名的枚举值。若要实现非中断性变更，旧客户端在接收新枚举值时必须正确运行。</li>\n</ul>\n\n        <h3 id=\"二进制中断性变更\"   >\n          <a href=\"#二进制中断性变更\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#二进制中断性变更\" class=\"headerlink\" title=\"二进制中断性变更\"></a>二进制中断性变更</h3>\n      <p>以下变更在grpc协议级别是非中断性变更，但如果客户端升级到最新到.proto协议或客户端程序集，则需要对其进行更新。如果你计划将grpc库发布到NuGet，二进制兼容性很重要。</p>\n<ul>\n<li>删除字段 - 已删除字段中的值被反序列化为消息的未知类型，这并不是grpc协议中断性变更，但如果客户端升级到最新的协定，则需要对其更新。删除的字段编号不会在将来被意外重用，这点很重要。若要确保不会发生这种情况，请使用protobuf的保留关键字指定已删除的字段名称或者编号。</li>\n<li>重命名消息 - 消息名称通常不会在网络上发送，因此这不是grpc协议中断性变更。如果客户端升级到最新的协定，则需要对其进行更新。当消息名称用于标识消息类型时，任何字段都会出现消息名称在网络上发送的情况。</li>\n<li>嵌套或取消嵌套 - 消息类型可以嵌套。嵌套或取消嵌套消息将更改其消息名称。更改消息类型的嵌套方式对兼容性的影响与重命名相同。</li>\n<li>更改csharp_namespace - 更改csharp_namespace将更改所生成的pb代码类型的命名空间。这并不是grpc协议中断性变更，但如果客户端升级到最新的协定，则需要对其进行更新。</li>\n</ul>\n\n        <h3 id=\"协议中断性变更\"   >\n          <a href=\"#协议中断性变更\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#协议中断性变更\" class=\"headerlink\" title=\"协议中断性变更\"></a>协议中断性变更</h3>\n      <p>以下各项是协议和二进制的中断性变更。</p>\n<ul>\n<li>重命名字段 - 对于Protobuf内容，字段名只在生成的代码中使用。字段编号用于标识网络上的字段。对于Protobuf来说，重命名字段不是协议性变更。但是，如果服务器正在使用JSON内容，则重命名字段是一个中断性变更。</li>\n<li>更改字段数据类型 - 将字段的数据类型更改为<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://developers.google.com/protocol-buffers/docs/proto3#updating\" >不兼容的类型</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>将在反序列化消息时导致错误。即使新的数据类型是兼容的，但如果客户端升级到最新的协定，它也可能需要更新以支持新的类型。</li>\n<li>更改字段编号 - 对于Protobuf有效负载，字段编号用于标识网络上的字段。</li>\n<li>重命名包、服务或方法 - grpc使用包名、服务名和方法名来生成URL。客户端从服务器获取UNIMPLEMENTED状态。</li>\n<li>删除服务或方法 - 客户端在调用已删除的方法时从服务器获取UNIMPLEMENTED状态。</li>\n</ul>\n\n        <h3 id=\"行为中断性变更\"   >\n          <a href=\"#行为中断性变更\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#行为中断性变更\" class=\"headerlink\" title=\"行为中断性变更\"></a>行为中断性变更</h3>\n      <p>在进行非行为中断性变更时，还需要考虑旧客户端是否可以继续使用新的服务行为。例如，向请求字段添加新字段：</p>\n<ul>\n<li>它不是协议中断性变更</li>\n<li>如果未设置新字段，则在服务器上返回错误状态对于旧客户端来说是一个中断性变更。</li>\n</ul>\n<p>行为兼容性由应用特定的代码决定。</p>\n\n        <h3 id=\"版本号服务\"   >\n          <a href=\"#版本号服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#版本号服务\" class=\"headerlink\" title=\"版本号服务\"></a>版本号服务</h3>\n      <p>服务应尽量保持与旧客户端的后向兼容。 最终对应用的更改可能需要进行中断性变更。 中断旧客户端并强制其随服务一起更新不是一种好的用户体验。 若要在进行中断性变更的同时保持后向兼容性，一种方法是发布服务的多个版本。</p>\n<p>gRPC 支持可选的包说明符，它的功能非常类似于 .NET 命名空间。 实际上，如果 .proto 文件中未设置 option csharp_namespace，则 package 将用作生成的 .NET 类型的 .NET 命名空间。 该包可用于指定服务的版本号及其消息：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax &#x3D; &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package greet.v1;</span><br><span class=\"line\"></span><br><span class=\"line\">service Greeter &#123;</span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  string name &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  string message &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>包名称与服务名称相结合以标识服务地址。 服务地址允许并行托管服务的多个版本：</p>\n<ul>\n<li>greet.v1.Greeter</li>\n<li>greet.v2.Greeter</li>\n</ul>\n<p>已进行版本控制的服务的实现在 Startup.cs 中注册：</p>\n<figure class=\"highlight c#\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">app.UseEndpoints(endpoints =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Implements greet.v1.Greeter</span></span><br><span class=\"line\">    endpoints.MapGrpcService&lt;GreeterServiceV1&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Implements greet.v2.Greeter</span></span><br><span class=\"line\">    endpoints.MapGrpcService&lt;GreeterServiceV2&gt;();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p>通过在包名称中包含版本号，你可发布具有中断性变更的服务 v2 版本，同时继续支持调用 v1 版本的旧客户端 。 更新客户端以使用 v2 服务后，你可选择删除旧版本。 计划发布服务的多个版本时：</p>\n<ul>\n<li>如果合理，请避免中断性变更。</li>\n<li>除非进行中断性更改，否则请勿更新版本号。</li>\n<li>进行中断性变更时，请务必更新版本号。</li>\n</ul>\n<p>发布多个服务版本会使其重复。 若要减少重复，请考虑将业务逻辑从服务实现移动到可由新旧实现重用的集中位置：</p>\n<figure class=\"highlight c#\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Greet.V1;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Grpc.Core;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Services</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GreeterServiceV1</span> : <span class=\"title\">Greeter.GreeterBase</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> IGreeter _greeter;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreeterServiceV1</span>(<span class=\"params\">IGreeter greeter</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            _greeter = greeter;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> Task&lt;HelloReply&gt; <span class=\"title\">SayHello</span>(<span class=\"params\">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Task.FromResult(<span class=\"keyword\">new</span> HelloReply</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Message = _greeter.GetHelloMessage(request.Name)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>使用不同包名称生成的服务和消息属于不同的 .NET 类型。 将业务逻辑移动到集中位置需要将消息映射到常见类型。</p>\n\n        <h3 id=\"原文地址\"   >\n          <a href=\"#原文地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h3>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://docs.microsoft.com/zh-cn/aspnet/core/grpc/versioning?view=aspnetcore-5.0\" >https://docs.microsoft.com/zh-cn/aspnet/core/grpc/versioning?view=aspnetcore-5.0</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["rpc"],"tags":["grpc"]},{"title":"预测性负载均衡","url":"/2021/07/03/%E9%A2%84%E6%B5%8B%E6%80%A7%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","content":"<p>Steve Gury 的“预测性负载均衡：不公平但更快、更健壮”</p>\n\n        <h2 id=\"客户端负载均衡方法\"   >\n          <a href=\"#客户端负载均衡方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#客户端负载均衡方法\" class=\"headerlink\" title=\"客户端负载均衡方法\"></a>客户端负载均衡方法</h2>\n      <ul>\n<li>许多可用的服务器，选择哪一个</li>\n</ul>\n\n        <h3 id=\"随机选择\"   >\n          <a href=\"#随机选择\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#随机选择\" class=\"headerlink\" title=\"随机选择\"></a>随机选择</h3>\n      <a id=\"more\"></a>\n<ul>\n<li>随机选择服务器</li>\n<li>随着（永远）时间的推移，所有服务器收到相同数量的请求</li>\n<li>在短期内，真的可以给出不平衡的选择</li>\n</ul>\n\n        <h3 id=\"轮询调度\"   >\n          <a href=\"#轮询调度\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#轮询调度\" class=\"headerlink\" title=\"轮询调度\"></a>轮询调度</h3>\n      <ul>\n<li>客户端记住前一个服务器</li>\n<li>选择列表中的下一个</li>\n</ul>\n\n        <h3 id=\"最小负载\"   >\n          <a href=\"#最小负载\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#最小负载\" class=\"headerlink\" title=\"最小负载\"></a>最小负载</h3>\n      <ul>\n<li>客户端跟踪每个服务器上的未完成请求</li>\n<li>选择未完成请求数量最少的服务器</li>\n<li>[这听起来像是本地负载最少，客户端不知道服务器上的全局负载]</li>\n</ul>\n\n        <h2 id=\"负载均衡问题\"   >\n          <a href=\"#负载均衡问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#负载均衡问题\" class=\"headerlink\" title=\"负载均衡问题\"></a>负载均衡问题</h2>\n      \n        <h3 id=\"服务器并不完全相同\"   >\n          <a href=\"#服务器并不完全相同\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#服务器并不完全相同\" class=\"headerlink\" title=\"服务器并不完全相同\"></a>服务器并不完全相同</h3>\n      <ul>\n<li>有些服务器可能更隐蔽</li>\n<li>轮训调度将请求到这些服务器上，使许多请求非常慢</li>\n<li>主负载需求将更少</li>\n</ul>\n\n        <h3 id=\"惊群效应\"   >\n          <a href=\"#惊群效应\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#惊群效应\" class=\"headerlink\" title=\"惊群效应\"></a>惊群效应</h3>\n      <ul>\n<li>新的可用资源被请求轰炸</li>\n<li>新可用的资源可能还没有准备好</li>\n<li>[似乎与 Wikipedia 对 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Thundering_herd_problem\" >Thudnering Herd Problem</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> 的定义不太一样]</li>\n<li>轮询和随机不会轰炸新可用的资源</li>\n<li>主负载会被轰击</li>\n</ul>\n\n        <h3 id=\"异常值\"   >\n          <a href=\"#异常值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#异常值\" class=\"headerlink\" title=\"异常值\"></a>异常值</h3>\n      <ul>\n<li>服务器可能会遇到问题<ul>\n<li>例如 GC 暂停，CPU 峰值阻止处理</li>\n</ul>\n</li>\n<li>轮询将继续打击这些暂时缓慢的服务器</li>\n<li>最小负载可能会好一点</li>\n</ul>\n\n        <h3 id=\"具有独立状态的多个客户端\"   >\n          <a href=\"#具有独立状态的多个客户端\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#具有独立状态的多个客户端\" class=\"headerlink\" title=\"具有独立状态的多个客户端\"></a>具有独立状态的多个客户端</h3>\n      <ul>\n<li>假设没有协调的全局状态</li>\n<li>每个客户端都有服务器负载的视图</li>\n<li>最小负载和轮询可能会选择全局加载最少的服务器</li>\n</ul>\n\n        <h2 id=\"所有这些方法都有问题\"   >\n          <a href=\"#所有这些方法都有问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#所有这些方法都有问题\" class=\"headerlink\" title=\"所有这些方法都有问题\"></a>所有这些方法都有问题</h2>\n      <p><img src=\"/images/linux/slb/predictive_load_balancing_matrix.png\" alt=\"predictive_load_balancing_matrix\"></p>\n<ul>\n<li>[我认为不是针对最少负载提出的最佳观点]</li>\n</ul>\n\n        <h3 id=\"基于延迟的负载平衡\"   >\n          <a href=\"#基于延迟的负载平衡\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#基于延迟的负载平衡\" class=\"headerlink\" title=\"基于延迟的负载平衡\"></a>基于延迟的负载平衡</h3>\n      \n        <h4 id=\"使用观察到的延迟作为负载的度量\"   >\n          <a href=\"#使用观察到的延迟作为负载的度量\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用观察到的延迟作为负载的度量\" class=\"headerlink\" title=\"使用观察到的延迟作为负载的度量\"></a>使用观察到的延迟作为负载的度量</h4>\n      <p>*<em>负载 = Predicted_Latency * (#requests + 1)*</em></p>\n<ul>\n<li>每个服务器都有一个归因于它的延迟</li>\n<li>现在决定服务器取决于响应的预计到达时间</li>\n</ul>\n\n        <h4 id=\"预测延迟\"   >\n          <a href=\"#预测延迟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#预测延迟\" class=\"headerlink\" title=\"预测延迟\"></a>预测延迟</h4>\n      <ul>\n<li><p>响应延迟直方图的中位数（不是平均值）<br><img src=\"/images/linux/slb/predictive_load_balancing_median_latency.png\" alt=\"predictive_load_balancing_median_latency\"></p>\n</li>\n<li><p>比平均水平更稳定</p>\n</li>\n<li><p>滑动窗口上的直方图以说明最近的服务器更改</p>\n</li>\n<li><p>当历史数据陈旧时，延迟会衰减（自行下降）</p>\n<ul>\n<li>鼓励访问很久没见过的服务器，以防万一发生了变化</li>\n<li>如果服务器仍然很慢，它会重新提高延迟（一段时间后会再次衰减）</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"问题和解决方案\"   >\n          <a href=\"#问题和解决方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#问题和解决方案\" class=\"headerlink\" title=\"问题和解决方案\"></a>问题和解决方案</h4>\n      <ul>\n<li>如何估计新服务器（无历史数据）<ul>\n<li>解决方案：试用期预热服务器，建立历史</li>\n</ul>\n</li>\n<li>如果服务器返回错误但响应时间很快怎么办<ul>\n<li>解决方案：忽略错误延迟</li>\n<li>解决方案：使用失败响应来处置延迟</li>\n</ul>\n</li>\n</ul>\n\n        <h4 id=\"快速响应延迟\"   >\n          <a href=\"#快速响应延迟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#快速响应延迟\" class=\"headerlink\" title=\"快速响应延迟\"></a>快速响应延迟</h4>\n      <ul>\n<li><p>跟踪尚未收到响应的请求</p>\n</li>\n<li><p>如果响应尚未到达预测的时间，我们可以立即调整开始调整预测负载并继续调整它</p>\n</li>\n<li><p>如果需要调度其他请求，可以使用调整后的预测负载做出决定（在响应返回之前，或者发生大超时之前）<br><img src=\"/images/linux/slb/predictive_load_balancing_react_quickly.png\" alt=\"predictive_load_balancing_react_quickly\"></p>\n</li>\n<li><p>处理突发事件（GC 暂停、网络分区）时效果很好</p>\n</li>\n<li><p>需要平均一个中位延迟来检测死机/无响应的服务器</p>\n</li>\n</ul>\n\n        <h4 id=\"不完美\"   >\n          <a href=\"#不完美\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#不完美\" class=\"headerlink\" title=\"不完美\"></a>不完美</h4>\n      <ul>\n<li>延迟并不总是一个完美的信号</li>\n<li>冷服务器的缓慢预热<ul>\n<li>由于衰变，冷服务器会不时被访问</li>\n<li>尽管如此，他们在一段时间内的流量会相对较少</li>\n</ul>\n</li>\n<li>伪装成成功的错误混淆了系统</li>\n<li>请求分布可能暂时不均匀</li>\n</ul>\n\n        <h2 id=\"原文地址\"   >\n          <a href=\"#原文地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2>\n      <ul>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html\" >http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n","categories":["linux"],"tags":["slb"]},{"title":"透视http协议 (一)","url":"/2021/06/05/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE%20(%E4%B8%80)/","content":"\n        <h2 id=\"HTTP的前世今生\"   >\n          <a href=\"#HTTP的前世今生\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP的前世今生\" class=\"headerlink\" title=\"HTTP的前世今生\"></a>HTTP的前世今生</h2>\n      <p>HTTP 协议是怎么来的？它最开始是什么样子的？又是如何一步一步发展到今天，几乎“统治”了整个互联网世界的呢？</p>\n\n        <h3 id=\"史前时期\"   >\n          <a href=\"#史前时期\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#史前时期\" class=\"headerlink\" title=\"史前时期\"></a>史前时期</h3>\n      <p>20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。</p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"创世纪\"   >\n          <a href=\"#创世纪\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#创世纪\" class=\"headerlink\" title=\"创世纪\"></a>创世纪</h3>\n      <p>1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。</p>\n<ol>\n<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>\n<li>HTML：即超文本标记语言，描述超文本文档；</li>\n<li>HTTP：即超文本传输协议，用来传输超文本。</li>\n</ol>\n<p>基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。</p>\n\n        <h3 id=\"HTTP-0-9\"   >\n          <a href=\"#HTTP-0-9\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h3>\n      <p>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p>\n<p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。</p>\n\n        <h3 id=\"HTTP-1-0\"   >\n          <a href=\"#HTTP-1-0\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h3>\n      <p>1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。</p>\n<p>同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。</p>\n<p>更的多的人开始使用互联网,促进了 HTTP 的发展。于是在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</p>\n<ol>\n<li>增加了 HEAD、POST 等新方法；</li>\n<li>增加了响应状态码，标记可能的错误原因；</li>\n<li>引入了协议版本号概念；</li>\n<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>\n<li>传输的数据不再仅限于文本。</li>\n</ol>\n\n        <h3 id=\"HTTP-1-1\"   >\n          <a href=\"#HTTP-1-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h3>\n      <p>1999 年，HTTP/1.1 发布了 RFC 文档,编号为 2616。HTTP/1.1 是对 HTTP/1.0 的小幅度修正，它是一个“正式的标准”，而不是一份可有可无的“参考文档”。意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p>\n<p>HTTP/1.1 主要的变更点有：</p>\n<ol>\n<li>增加了 PUT、DELETE 等新的方法；</li>\n<li>增加了缓存管理和控制；明确了连接管理，允许持久连接；</li>\n<li>允许响应数据分块（chunked），利于传输大文件；</li>\n<li>强制要求 Host 头，让互联网主机托管成为可能。</li>\n</ol>\n\n        <h3 id=\"HTTP-2\"   >\n          <a href=\"#HTTP-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h3>\n      <p>Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</p>\n<p>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</p>\n<ol>\n<li>二进制协议，不再是纯文本；</li>\n<li>可发起多个请求，废弃了 1.1 里的管道；</li>\n<li>使用专用算法压缩头部，减少数据传输量；</li>\n<li>允许服务器主动向客户端推送数据；增强了安全性，“事实上”要求加密通信。</li>\n</ol>\n\n        <h3 id=\"HTTP-3\"   >\n          <a href=\"#HTTP-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-3\" class=\"headerlink\" title=\"HTTP/3\"></a>HTTP/3</h3>\n      <p>Google 发明的另一个个新的协议 QUIC （Quick UDP Internet Connection）,2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段。</p>\n\n        <h3 id=\"小结\"   >\n          <a href=\"#小结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；</li>\n<li>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</li>\n<li>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</li>\n<li>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</li>\n<li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</li>\n<li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</li>\n</ol>\n\n        <h2 id=\"HTTP是什么？HTTP又不是什么？\"   >\n          <a href=\"#HTTP是什么？HTTP又不是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP是什么？HTTP又不是什么？\" class=\"headerlink\" title=\"HTTP是什么？HTTP又不是什么？\"></a>HTTP是什么？HTTP又不是什么？</h2>\n      <p>HTTP 就是超文本传输协议，也就是 HyperText Transfer Protocol。</p>\n\n        <h3 id=\"HTTP-是什么\"   >\n          <a href=\"#HTTP-是什么\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-是什么\" class=\"headerlink\" title=\"HTTP 是什么\"></a>HTTP 是什么</h3>\n      <p>“超文本传输协议”，分别是：“超文本”“传输”和“协议”</p>\n<p><strong>HTTP 是一个协议</strong></p>\n<p>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</p>\n<p><strong>HTTP 是一个“传输协议”</strong></p>\n<p>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</p>\n<p><strong>超文本</strong></p>\n<p>所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。</p>\n<p><strong>HTTP（超文本传输协议）的定义</strong><br>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>\n\n        <h3 id=\"HTTP-不是什么？\"   >\n          <a href=\"#HTTP-不是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP-不是什么？\" class=\"headerlink\" title=\"HTTP 不是什么？\"></a>HTTP 不是什么？</h3>\n      <p>HTTP 是一个协议，不存在“单独的实体”。它不是浏览器、手机 APP 那样的应用程序，也不是 Windows、Linux 那样的操作系统，更不是 Apache、Nginx、Tomcat 那样的 Web 服务器。</p>\n<ul>\n<li>HTTP 不是互联网。</li>\n<li>HTTP 不是编程语言</li>\n<li>HTTP 不是 HTML</li>\n<li>HTTP 不是一个孤立的协议</li>\n</ul>\n<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>\n\n        <h3 id=\"小结-1\"   >\n          <a href=\"#小结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ul>\n<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>\n<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。</li>\n<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>\n<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>\n</ul>\n\n        <h2 id=\"HTTP世界全览-上\"   >\n          <a href=\"#HTTP世界全览-上\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP世界全览-上\" class=\"headerlink\" title=\"HTTP世界全览 - 上\"></a>HTTP世界全览 - 上</h2>\n      <p>介绍HTTP 相关的各种概念和角色，清楚它们在链路中的位置和作用，以及发起一个 HTTP 请求会有哪些角色参与，会如何影响请求的处理。</p>\n\n        <h3 id=\"网络世界\"   >\n          <a href=\"#网络世界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#网络世界\" class=\"headerlink\" title=\"网络世界\"></a>网络世界</h3>\n      <p>互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p>\n<p>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</p>\n\n        <h3 id=\"浏览器\"   >\n          <a href=\"#浏览器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3>\n      <p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，浏览器的正式名字叫“Web Browser”，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。</p>\n<p>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。例如，HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，还有开发者工具用来调试网页。</p>\n<p>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。通常都简单地称之为“客户端”。</p>\n\n        <h3 id=\"Web-服务器\"   >\n          <a href=\"#Web-服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Web-服务器\" class=\"headerlink\" title=\"Web 服务器\"></a>Web 服务器</h3>\n      <p>协议另一端的应答方（响应方）就是服务器，Web Server。</p>\n<p>Web 服务器 有两个层面的含义：硬件和软件。</p>\n<p><strong>硬件</strong>含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。<br><strong>软件</strong>是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。</p>\n\n        <h3 id=\"CDN\"   >\n          <a href=\"#CDN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3>\n      <p>浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</p>\n<p>CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p>\n<p>CDN 可以缓存源站的数据，可以找到离用户最近的节点，大幅度缩短响应时间。</p>\n\n        <h3 id=\"HTML-WebService-WAF\"   >\n          <a href=\"#HTML-WebService-WAF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTML-WebService-WAF\" class=\"headerlink\" title=\"HTML/WebService/WAF\"></a>HTML/WebService/WAF</h3>\n      <p>HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</p>\n<p>Web Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。</p>\n<p>WAF 是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。</p>\n<p>WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p>\n<ol>\n<li>互联网上绝大部分资源都使用 HTTP 协议传输；</li>\n<li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li>\n<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>\n<li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>\n<li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li>\n</ol>\n\n        <h2 id=\"HTTP世界全览-下\"   >\n          <a href=\"#HTTP世界全览-下\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP世界全览-下\" class=\"headerlink\" title=\"HTTP世界全览 - 下\"></a>HTTP世界全览 - 下</h2>\n      <p>与HTTP 相关的 TCP/IP、DNS、URI、HTTPS 等相关协议介绍。</p>\n\n        <h3 id=\"TCP-IP\"   >\n          <a href=\"#TCP-IP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3>\n      <p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>\n<p>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。</p>\n<p>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。</p>\n<p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。但互联网的快速发展让地址的分配管理很快就耗尽了，所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个。</p>\n<p>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</p>\n<p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p>\n<p>HTTP 是一个”传输协议”，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。</p>\n\n        <h3 id=\"DNS\"   >\n          <a href=\"#DNS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3>\n      <p>域名系统（Domain Name System），为了将一串无意义的数字通过一串有意义的字符表示更好的记忆。</p>\n<p>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</p>\n<p>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等。</p>\n<p>想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是“域名解析”。</p>\n<p>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。</p>\n<p>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p>\n\n        <h3 id=\"URI-URL\"   >\n          <a href=\"#URI-URL\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#URI-URL\" class=\"headerlink\" title=\"URI/URL\"></a>URI/URL</h3>\n      <p>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>\n<p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p>\n<p>如：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html</span><br></pre></td></tr></table></div></figure>\n<p>可以看到，URI 主要有三个基本的部分构成：</p>\n<ol>\n<li>协议名：即访问该资源应当使用的协议，在这里是“http”；</li>\n<li>主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</li>\n<li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</li>\n</ol>\n\n        <h3 id=\"HTTPS\"   >\n          <a href=\"#HTTPS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3>\n      <p>HTTPS 它的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。</p>\n<p>这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”。</p>\n<p>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</p>\n<p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>\n<p>浏览器地址栏，如果有一个小锁头标志，那就表明网站启用了安全的 HTTPS 协议，而 URI 里的协议名，也从“http”变成了“https”。</p>\n\n        <h3 id=\"代理\"   >\n          <a href=\"#代理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3>\n      <p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</p>\n<p>代理有很多的种类，常见的有：</p>\n<ol>\n<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>\n<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>\n<li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li>\n<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>\n</ol>\n<p>CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>\n<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多事情，比如：</p>\n<ol>\n<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>\n<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>\n<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>\n<li>数据处理：提供压缩、加密等额外的功能。</li>\n</ol>\n<p>关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订。</p>\n\n        <h3 id=\"小结-2\"   >\n          <a href=\"#小结-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>\n<li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</li>\n<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>\n<li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；</li>\n<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>\n</ol>\n\n        <h3 id=\"小贴士\"   >\n          <a href=\"#小贴士\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小贴士\" class=\"headerlink\" title=\"小贴士\"></a>小贴士</h3>\n      <ul>\n<li>IP 协议曾经有v1,v2, v3等早期版本，但因为不够完善而没有对外发布。而v5 则是仅用于实验室内部研究，从未公开，所以我们看到的只有v4和v6两个版本。</li>\n<li>2011年2月互联网组织ICANN 正式宣布IPV4 地址被”用尽”</li>\n<li>如果使用 UNIX/Linux 操作系统，HTTP可以运行在本机的 UNIX Domain Socket 上，它也是一种进程间通信机制，但也可以满足HTTP 对下层对可靠传输要求，所以就成了”HTTP over UNIX Domain Soocket”。</li>\n</ul>\n\n        <h2 id=\"常说的“四层”和“七层”到底是什么？\"   >\n          <a href=\"#常说的“四层”和“七层”到底是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常说的“四层”和“七层”到底是什么？\" class=\"headerlink\" title=\"常说的“四层”和“七层”到底是什么？\"></a>常说的“四层”和“七层”到底是什么？</h2>\n      <p>TCP/IP 协议，它是 HTTP 协议的下层协议，负责具体的数据传输工作。强调了 TCP/IP 协议是一个 <strong>“有层次的协议栈”</strong>。</p>\n\n        <h3 id=\"TCP-IP-网络分层模型\"   >\n          <a href=\"#TCP-IP-网络分层模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP-网络分层模型\" class=\"headerlink\" title=\"TCP/IP 网络分层模型\"></a>TCP/IP 网络分层模型</h3>\n      <p>TCP/IP 创造性地提出了“分层”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。</p>\n<p>如图所示：</p>\n<img src=\"/images/http/gk/tcp-layer.png\" art=\"tcp_layer\" width=\"400px\">\n\n<p>TCP/IP 协议总共有四层，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。</p>\n<p>从下往上看：</p>\n<p>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>\n<p>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>\n<p>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>\n<p>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</p>\n<p>协议栈的第四层叫“应用层”（application layer），有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有 HTTP。</p>\n<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>\n\n        <h3 id=\"OSI-网络分层模型\"   >\n          <a href=\"#OSI-网络分层模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#OSI-网络分层模型\" class=\"headerlink\" title=\"OSI 网络分层模型\"></a>OSI 网络分层模型</h3>\n      <p>OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。</p>\n<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>\n<img src=\"/images/http/gk/osi-layer.png\" art=\"osi_layer\" width=\"400px\">\n\n<ol>\n<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>\n<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>\n<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>\n<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>\n<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>\n<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>\n<li>第七层：应用层，面向具体的应用传输数据。</li>\n</ol>\n\n        <h3 id=\"两个分层模型的映射关系\"   >\n          <a href=\"#两个分层模型的映射关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#两个分层模型的映射关系\" class=\"headerlink\" title=\"两个分层模型的映射关系\"></a>两个分层模型的映射关系</h3>\n      <img src=\"/images/http/gk/tcp-osi-map.png\" art=\"tcp-osi-map\" width=\"400px\">\n\n<ol>\n<li>第一层：物理层，TCP/IP 里无对应；</li>\n<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>\n<li>第三层：网络层，对应 TCP/IP 的网际层；</li>\n<li>第四层：传输层，对应 TCP/IP 的传输层；</li>\n<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>\n</ol>\n<p>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义</p>\n<p>“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>\n<p>“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>\n\n        <h3 id=\"TCP-IP-协议栈的工作方式\"   >\n          <a href=\"#TCP-IP-协议栈的工作方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#TCP-IP-协议栈的工作方式\" class=\"headerlink\" title=\"TCP/IP 协议栈的工作方式\"></a>TCP/IP 协议栈的工作方式</h3>\n      <p>发送数据的过程：</p>\n<ol>\n<li>在应用层，HTTP 协议为它加一个 HTTP 专用附加数据</li>\n<li>在 TCP 层给数据再次打包，加上了 TCP 头</li>\n<li>IP 层为TCP 数据包加上了 IP 头</li>\n<li>MAC 层对TCP 数据包加上MAC 头</li>\n<li>之后经过网络传输到达重点</li>\n<li>目标服务经过拆包 去掉 mac头 ip头和TCP头 获取到真正数据</li>\n</ol>\n<p>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</p>\n<p>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</p>\n\n        <h3 id=\"小结-3\"   >\n          <a href=\"#小结-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；</li>\n<li>OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；</li>\n<li>OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；</li>\n<li>日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；</li>\n<li>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</li>\n</ol>\n<p>辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：</p>\n<ul>\n<li>凡是由操作系统负责处理的就是四层或四层以下</li>\n<li>凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</li>\n</ul>\n\n        <h3 id=\"小贴士-1\"   >\n          <a href=\"#小贴士-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小贴士-1\" class=\"headerlink\" title=\"小贴士\"></a>小贴士</h3>\n      <ol>\n<li>MAC地址（Media Access Control Address）也称为局域网地址，可以唯一的标识一个网卡，也就同时标识了此网卡的设备。</li>\n<li>在 TCP/IP 协议栈之外，还有一些协议位于OSI 五层和六层的，例如：UNIX 域套接字就可以认为是在五层。</li>\n</ol>\n\n        <h2 id=\"域名里有哪些门道？\"   >\n          <a href=\"#域名里有哪些门道？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名里有哪些门道？\" class=\"headerlink\" title=\"域名里有哪些门道？\"></a>域名里有哪些门道？</h2>\n      \n        <h3 id=\"域名的形式\"   >\n          <a href=\"#域名的形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名的形式\" class=\"headerlink\" title=\"域名的形式\"></a>域名的形式</h3>\n      <p>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</p>\n<p>最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务。</p>\n<p>如： time.geekbang.org 这里的“org”就是顶级域名，“geekbang”是二级域名，“time”则是主机名。</p>\n<p>域名不仅能够代替 IP 地址，还有许多其他的用途</p>\n<p>在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;                       #监听80端口</span><br><span class=\"line\">    server_name  time.geekbang.org;  #主机名是time.geekbang.org</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"域名的解析\"   >\n          <a href=\"#域名的解析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名的解析\" class=\"headerlink\" title=\"域名的解析\"></a>域名的解析</h3>\n      <p>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。</p>\n<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>\n<ol>\n<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>\n<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>\n<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.apple.com/\" >www.apple.com</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> 的 IP 地址。</li>\n</ol>\n<img src=\"/images/http/gk/dns.png\" art=\"dns\" width=\"400px\">\n\n<p>目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。</p>\n<p>例如，你要访问“<a href=\"http://www.apple.com”，就要进行下面的三次查询：\">www.apple.com”，就要进行下面的三次查询：</a></p>\n<ol>\n<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>\n<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>\n<li>最后访问“apple.com”域名服务器，就得到了“<span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.apple.com”的地址./\" >www.apple.com”的地址。</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n<p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</p>\n<p>许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>\n<p>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>\n<p>其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“<span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.apple.com”,那么下一次在浏览器里再输入这个网址的时候就不会再跑到/\" >www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>\n<p>另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\\WINDOWS\\system32\\drivers\\etc\\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p>\n<p>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力。</p>\n<p>如图：完整地表示了现在的 DNS 架构。</p>\n<img src=\"/images/http/gk/dns-now.png\" art=\"dns-now\" width=\"400px\">\n\n<p>在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">resolver 8.8.8.8 valid&#x3D;30s;  #指定Google的DNS，缓存30秒</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"域名的“新玩法”\"   >\n          <a href=\"#域名的“新玩法”\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#域名的“新玩法”\" class=\"headerlink\" title=\"域名的“新玩法”\"></a>域名的“新玩法”</h3>\n      <p>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</p>\n<p>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名。</p>\n<p>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。</p>\n<p>这种“玩法”也有两种方式，两种方式可以混用。</p>\n<p>第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</p>\n<p>第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</p>\n<p><strong>恶意的“玩法”</strong></p>\n<ul>\n<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>\n<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>\n</ul>\n\n        <h3 id=\"小结-4\"   >\n          <a href=\"#小结-4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；</li>\n<li>DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；</li>\n<li>DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；</li>\n<li>使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。</li>\n</ol>\n\n        <h3 id=\"小贴士-2\"   >\n          <a href=\"#小贴士-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小贴士-2\" class=\"headerlink\" title=\"小贴士\"></a>小贴士</h3>\n      <p>域名的总长度限制在253个字符以内，而每一级域名长度不能超过63个字符。</p>\n\n        <h3 id=\"课程来源\"   >\n          <a href=\"#课程来源\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#课程来源\" class=\"headerlink\" title=\"课程来源\"></a>课程来源</h3>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://time.geekbang.org/column/intro/100029001\" >https://time.geekbang.org/column/intro/100029001</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>欢迎大家订购，一块儿学习，共同进步。</p>\n","categories":["http"],"tags":["http","TCP/IP"]},{"title":"透视http协议 (二)","url":"/2021/07/04/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE%20(%E4%BA%8C)/","content":"\n        <h2 id=\"键入网址再按下回车，发生了什么？\"   >\n          <a href=\"#键入网址再按下回车，发生了什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#键入网址再按下回车，发生了什么？\" class=\"headerlink\" title=\"键入网址再按下回车，发生了什么？\"></a>键入网址再按下回车，发生了什么？</h2>\n      \n        <h3 id=\"使用-IP-地址访问-Web-服务器\"   >\n          <a href=\"#使用-IP-地址访问-Web-服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用-IP-地址访问-Web-服务器\" class=\"headerlink\" title=\"使用 IP 地址访问 Web 服务器\"></a>使用 IP 地址访问 Web 服务器</h3>\n      <ol>\n<li>浏览器从地址栏的输入中获得服务器的IP 地址和端口号；</li>\n<li>浏览器用 TCP 的三次握手与服务器建立连接；<a id=\"more\"></a></li>\n<li>浏览器向服务器发送拼好的报文；</li>\n<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>\n<li>浏览器解析报文，渲染输出页面。</li>\n</ol>\n\n        <h3 id=\"使用域名访问-Web-服务器\"   >\n          <a href=\"#使用域名访问-Web-服务器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#使用域名访问-Web-服务器\" class=\"headerlink\" title=\"使用域名访问 Web 服务器\"></a>使用域名访问 Web 服务器</h3>\n      <p>首先会经过DNS解析，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，也就是 hosts 文件，windows为“C:\\WINDOWS\\system32\\drivers\\etc\\hosts”。</p>\n<p>DNS解析流程：</p>\n<p>先查浏览器缓存，然后是系统缓存-＞hosts文件-＞局域网域名服务器-＞广域网域名服务器-＞顶级域名服务器-＞根域名服务器。</p>\n\n        <h3 id=\"http-报文\"   >\n          <a href=\"#http-报文\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#http-报文\" class=\"headerlink\" title=\"http 报文\"></a>http 报文</h3>\n      <p>HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。</p>\n\n        <h4 id=\"报文结构\"   >\n          <a href=\"#报文结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h4>\n      <p>TCP 报文来看，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</p>\n<p>有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。</p>\n<img src=\"/images/http/gk/tcp-header.webp\" art=\"http-header\" width=\"500px\">\n\n<p>HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。</p>\n<p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>\n<ol>\n<li>起始行（start line）：描述请求或响应的基本信息；</li>\n<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>\n<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>\n</ol>\n<p>这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。</p>\n<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>\n<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>\n<img src=\"/images/http/gk/http-header.webp\" art=\"http-header\" width=\"500px\">\n\n<p>http header头</p>\n<img src=\"/images/http/gk/http-header-code.webp\" art=\"http-header\" width=\"500px\">\n\n<p>第一行“GET / HTTP/1.1”就是请求行，而后面的“Host”“Connection”等等都属于 header，报文的最后是一个空白行结束，没有 body。</p>\n\n        <h5 id=\"请求行\"   >\n          <a href=\"#请求行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h5>\n      <p>请求行由三部分构成：</p>\n<ol>\n<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>\n<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>\n<li>版本号：表示报文使用的 HTTP 协议版本。</li>\n</ol>\n<p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>\n<img src=\"/images/http/gk/request-line.webp\" art=\"request-line\" width=\"500px\">\n\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET &#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></div></figure>\n<p>在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</p>\n\n        <h5 id=\"状态行\"   >\n          <a href=\"#状态行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#状态行\" class=\"headerlink\" title=\"状态行\"></a>状态行</h5>\n      <p>意思是服务器响应的状态。</p>\n<p>状态行也是由三部分构成:</p>\n<ol>\n<li>版本号：表示报文使用的 HTTP 协议版本；</li>\n<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>\n<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>\n</ol>\n<img src=\"/images/http/gk/status-line.webp\" art=\"status-line\" width=\"500px\">\n\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></div></figure>\n<p>意思就是：“请求完成，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</p>\n\n        <h5 id=\"头部字段\"   >\n          <a href=\"#头部字段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#头部字段\" class=\"headerlink\" title=\"头部字段\"></a>头部字段</h5>\n      <p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头</p>\n<p>如图：</p>\n<img src=\"/images/http/gk/request-h.webp\" art=\"request-h\" width=\"500px\">\n<img src=\"/images/http/gk/response-h.webp\" art=\"response-h\" width=\"500px\">\n\n<p>请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以我把请求头和响应头里的字段放在一起介绍。</p>\n<p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</p>\n<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>\n<p>不过使用头字段需要注意下面几点：</p>\n<ol>\n<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>\n<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>\n<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>\n<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>\n<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>\n</ol>\n\n        <h5 id=\"常用头字段\"   >\n          <a href=\"#常用头字段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#常用头字段\" class=\"headerlink\" title=\"常用头字段\"></a>常用头字段</h5>\n      <p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>\n<ol>\n<li>通用字段：在请求头和响应头里都可以出现；</li>\n<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>\n<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>\n<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>\n</ol>\n<p>首先要说的是 Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。</p>\n\n        <h6 id=\"Host\"   >\n          <a href=\"#Host\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Host\" class=\"headerlink\" title=\"Host\"></a>Host</h6>\n      <p>Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p>\n<p>例如在 127.0.0.1 上有三个虚拟主机：“<span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://www.chrono.com”“www.metroid.net”和“origin.io”.那么当使用域名的方式访问时,就必须要用/\" >www.chrono.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理。</p>\n\n        <h6 id=\"User-Agent\"   >\n          <a href=\"#User-Agent\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#User-Agent\" class=\"headerlink\" title=\"User-Agent\"></a>User-Agent</h6>\n      <p>User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</p>\n<p>但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。</p>\n\n        <h6 id=\"Date\"   >\n          <a href=\"#Date\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h6>\n      <p>Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p>\n<p>Server 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。</p>\n\n        <h6 id=\"Server\"   >\n          <a href=\"#Server\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h6>\n      <p>Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</p>\n<p>比如 GitHub，它的 Server 字段里就看不出是使用了 Apache 还是 Nginx，只是显示为“GitHub.com”。</p>\n<img src=\"/images/http/gk/github-server.webp\" art=\"github-server\" width=\"500px\">\n\n\n        <h6 id=\"Content-Length\"   >\n          <a href=\"#Content-Length\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#Content-Length\" class=\"headerlink\" title=\"Content-Length\"></a>Content-Length</h6>\n      <p>Content-Length，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</p>\n\n        <h3 id=\"小结\"   >\n          <a href=\"#小结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>HTTP 报文结构由“起始行 + 头部 + 空行 + 实体”组成，简单地说就是“header+body”；2. HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行；</li>\n<li>请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；</li>\n<li>请求行有三部分：请求方法，请求目标和版本号；</li>\n<li>状态行也有三部分：版本号，状态码和原因字符串；</li>\n<li>头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；</li>\n<li>HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。</li>\n</ol>\n\n        <h2 id=\"应该如何理解请求方法？\"   >\n          <a href=\"#应该如何理解请求方法？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应该如何理解请求方法？\" class=\"headerlink\" title=\"应该如何理解请求方法？\"></a>应该如何理解请求方法？</h2>\n      \n        <h3 id=\"标准请求方法\"   >\n          <a href=\"#标准请求方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#标准请求方法\" class=\"headerlink\" title=\"标准请求方法\"></a>标准请求方法</h3>\n      <p>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式：</p>\n<ol>\n<li>GET：获取资源，可以理解为读取或者下载数据；</li>\n<li>HEAD：获取资源的元信息；</li>\n<li>POST：向资源提交数据，相当于写入或上传数据；</li>\n<li>PUT：类似 POST；</li>\n<li>DELETE：删除资源；</li>\n<li>CONNECT：建立特殊的连接隧道；</li>\n<li>OPTIONS：列出可对资源实行的方法；</li>\n<li>TRACE：追踪请求 - 响应的传输路径。</li>\n</ol>\n\n        <h3 id=\"GET-HEAD\"   >\n          <a href=\"#GET-HEAD\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#GET-HEAD\" class=\"headerlink\" title=\"GET/HEAD\"></a>GET/HEAD</h3>\n      <p>GET 方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的</p>\n<p>它的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</p>\n<p>GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。</p>\n<p>例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。</p>\n<p>HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。</p>\n<p>HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。</p>\n\n        <h3 id=\"POST-PUT\"   >\n          <a href=\"#POST-PUT\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#POST-PUT\" class=\"headerlink\" title=\"POST/PUT\"></a>POST/PUT</h3>\n      <p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p>\n<p>POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。</p>\n<p>PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。</p>\n<p>在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">➜  ~ telnet www.baidu.com 80</span><br><span class=\"line\">Trying 180.101.49.12...</span><br><span class=\"line\">Connected to www.a.shifen.com.</span><br><span class=\"line\">Escape character is &#39;^]&#39;.</span><br><span class=\"line\">POST &#x2F;10-2 HTTP&#x2F;1.1</span><br><span class=\"line\">Host: www.chrono.com</span><br><span class=\"line\">Content-Length: 17</span><br><span class=\"line\"></span><br><span class=\"line\">POST DATA IS HERE</span><br><span class=\"line\"></span><br><span class=\"line\">PUT &#x2F;10-2 HTTP&#x2F;1.1</span><br><span class=\"line\">Host: www.chrono.com</span><br><span class=\"line\">Content-Length: 16</span><br><span class=\"line\"></span><br><span class=\"line\">PUT DATA IS HERE</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"其他方法\"   >\n          <a href=\"#其他方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3>\n      <ul>\n<li>DELETE 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</li>\n<li>CONNECT 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</li>\n<li>OPTIONS 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</li>\n<li>TRACE 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</li>\n</ul>\n\n        <h3 id=\"扩展方法\"   >\n          <a href=\"#扩展方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#扩展方法\" class=\"headerlink\" title=\"扩展方法\"></a>扩展方法</h3>\n      <p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p>\n<p>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。</p>\n\n        <h3 id=\"安全与幂等\"   >\n          <a href=\"#安全与幂等\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#安全与幂等\" class=\"headerlink\" title=\"安全与幂等\"></a>安全与幂等</h3>\n      <p>安全与幂等。</p>\n<p>在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</p>\n<p>按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。</p>\n<p>而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</p>\n<p>所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</p>\n<p>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p>\n<p>POST 和 PUT 的幂等性质就略费解一点。</p>\n<p>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p>\n\n        <h3 id=\"小结-1\"   >\n          <a href=\"#小结-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；</li>\n<li>请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；</li>\n<li>最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；</li>\n<li>HEAD 方法是轻量级的 GET，用来获取资源的元信息；</li>\n<li>PUT 基本上是 POST 的同义词，多用于更新数据；</li>\n<li>“安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。</li>\n</ol>\n\n        <h2 id=\"你能写出正确的网址吗？\"   >\n          <a href=\"#你能写出正确的网址吗？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#你能写出正确的网址吗？\" class=\"headerlink\" title=\"你能写出正确的网址吗？\"></a>你能写出正确的网址吗？</h2>\n      <p>URI: 统一资源标识符（Uniform Resource Identifier）</p>\n<p>URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。</p>\n\n        <h3 id=\"URI-的格式\"   >\n          <a href=\"#URI-的格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#URI-的格式\" class=\"headerlink\" title=\"URI 的格式\"></a>URI 的格式</h3>\n      <p>URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。</p>\n<p>下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>\n<img src=\"/images/http/gk/uri-formation.webp\" art=\"uri-formation\" width=\"500px\">\n\n<p>URI 第一个组成部分叫 scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。</p>\n<p>最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</p>\n<p>在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。</p>\n<p>在“://”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号。</p>\n<p>主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。</p>\n<p>有了协议名和主机地址、端口号，再加上后面标记资源所在位置的 path，浏览器就可以连接服务器访问资源了。</p>\n<p>URI 里 path 采用了类似文件系统“目录”“路径”的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的“/”风格。其实也比较好理解，它与 scheme 后面的“://”是一致的。</p>\n<p>URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;nginx.org</span><br><span class=\"line\">http:&#x2F;&#x2F;www.chrono.com:8080&#x2F;11-1</span><br><span class=\"line\">https:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc7230</span><br><span class=\"line\">file:&#x2F;&#x2F;&#x2F;D:&#x2F;http_study&#x2F;www&#x2F;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"URI-的查询参数\"   >\n          <a href=\"#URI-的查询参数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#URI-的查询参数\" class=\"headerlink\" title=\"URI 的查询参数\"></a>URI 的查询参数</h3>\n      <p>使用“协议名 + 主机名 + 路径”的方式，已经可以精确定位网络上的任何资源了。但这还不够，很多时候我们还想在操作资源的时候附加一些额外的修饰参数。</p>\n<p>如获取商品图片，但想要一个 32×32 的缩略图版本；获取商品列表，但要按某种规则做分页和排序；跳转页面，但想要标记跳转前的原始页面。</p>\n<p>仅用“协议名 + 主机名 + 路径”的方式是无法适应这些场景的，所以 URI 后面还有一个“query”部分，它在 path 之后，用一个“?”开始，但不包含“?”，表示对资源附加的额外要求。这是个很形象的符号，比“://”要好的多，很明显地表示了“查询”的含义。</p>\n<p>查询参数 query 有一套自己的格式，是多个“key=value”的字符串，这些 KV 值用字符“&amp;”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。</p>\n\n        <h3 id=\"URI-的完整格式\"   >\n          <a href=\"#URI-的完整格式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#URI-的完整格式\" class=\"headerlink\" title=\"URI 的完整格式\"></a>URI 的完整格式</h3>\n      <p>URI 还有一个“真正”的完整形态，如下图所示。</p>\n<img src=\"/images/http/gk/uri-full-formation.webp\" art=\"uri-formation\" width=\"500px\">\n\n<p>这个“真正”形态比基本形态多了两部分。</p>\n<p>第一个多出的部分是协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</p>\n<p>第二个多出的部分是查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。</p>\n<p>但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。</p>\n\n        <h3 id=\"URI-的编码\"   >\n          <a href=\"#URI-的编码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#URI-的编码\" class=\"headerlink\" title=\"URI 的编码\"></a>URI 的编码</h3>\n      <p>URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</p>\n<p>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。</p>\n<p>例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</p>\n\n        <h3 id=\"小结-2\"   >\n          <a href=\"#小结-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；</li>\n<li>URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；</li>\n<li>scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；</li>\n<li>“host:port”表示资源所在的主机名和端口号；</li>\n<li>path 标记资源所在的位置；</li>\n<li>query 表示对资源附加的额外要求；</li>\n<li>在 URI 里对“@&amp;/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。</li>\n</ol>\n\n        <h2 id=\"响应状态码\"   >\n          <a href=\"#响应状态码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h2>\n      <p>状态行里有用的是中间的状态码（Status Code）了。它是一个十进制数字，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。</p>\n\n        <h3 id=\"状态码\"   >\n          <a href=\"#状态码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3>\n      <p>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0<del>99 不用，这样状态码的实际可用范围就大大缩小了，由 000</del>999 变成了 100~599。</p>\n<p>这五类的具体含义是：</p>\n<ul>\n<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>\n<li>2××：成功，报文已经收到并被正确处理；</li>\n<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>\n<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>\n<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>\n</ul>\n<p>目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。</p>\n\n        <h3 id=\"1××\"   >\n          <a href=\"#1××\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1××\" class=\"headerlink\" title=\"1××\"></a>1××</h3>\n      <p>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p>\n<p><strong>101 Switching Protocols</strong> 它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>\n\n        <h3 id=\"2××\"   >\n          <a href=\"#2××\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2××\" class=\"headerlink\" title=\"2××\"></a>2××</h3>\n      <p>2××类状态码表示服务器收到并成功处理了客户端的请求</p>\n<p><strong>“200 OK”</strong>是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>\n<p><strong>“204 No Content”</strong>是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。</p>\n<p><strong>“206 Partial Content”</strong>是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>\n<p>状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>\n\n        <h3 id=\"3××\"   >\n          <a href=\"#3××\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3××\" class=\"headerlink\" title=\"3××\"></a>3××</h3>\n      <p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p>\n<p><strong>“301 Moved Permanently”</strong>俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。</p>\n<p>与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>\n<p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”</p>\n<p><strong>“304 Not Modified”</strong>是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p>\n\n        <h3 id=\"4××\"   >\n          <a href=\"#4××\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4××\" class=\"headerlink\" title=\"4××\"></a>4××</h3>\n      <p>4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。</p>\n<p><strong>“400 Bad Request”</strong>是一个通用的错误码，表示请求报文有错误</p>\n<p><strong>“403 Forbidden”</strong>实际上不是客户端的请求出错，而是表示服务器禁止访问资源。</p>\n<p><strong>“404 Not Found”</strong>它的原意是资源在本服务器上未找到，所以无法提供给客户端。</p>\n<p>4××里还有一些开发中其他常用的：</p>\n<ul>\n<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET</li>\n<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文</li>\n<li>408 Request Timeout：请求超时，服务器等待了过长的时间</li>\n<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态</li>\n<li>413 Request Entity Too Large：请求报文里的 body 太大</li>\n<li>414 Request-URI Too Long：请求行里的 URI 太大</li>\n<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略</li>\n<li>431 Request Header Fields Too Large：请求头某个字段或总体太大</li>\n</ul>\n\n        <h3 id=\"5××\"   >\n          <a href=\"#5××\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5××\" class=\"headerlink\" title=\"5××\"></a>5××</h3>\n      <p>5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。</p>\n<p><strong>“500 Internal Server Error”</strong>与 400 类似，也是一个通用的错误码</p>\n<p><strong>“501 Not Implemented”</strong>表示客户端请求的功能还不支持</p>\n<p><strong>“502 Bad Gateway”</strong>通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误</p>\n<p><strong>“503 Service Unavailable”</strong>表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>\n<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</p>\n\n        <h3 id=\"小结-3\"   >\n          <a href=\"#小结-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>状态码在响应报文里表示了服务器对请求的处理结果；</li>\n<li>状态码后的原因短语是简单的文字描述，可以自定义；</li>\n<li>状态码是十进制的三位数，分为五类，从 100 到 599；2××类状态码表示成功，常用的有 200、204、206；</li>\n<li>3××类状态码表示重定向，常用的有 301、302、304；</li>\n<li>4××类状态码表示客户端错误，常用的有 400、403、404；</li>\n<li>5××类状态码表示服务器错误，常用的有 500、501、502、503。</li>\n</ol>\n\n        <h2 id=\"HTTP有哪些特点？\"   >\n          <a href=\"#HTTP有哪些特点？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#HTTP有哪些特点？\" class=\"headerlink\" title=\"HTTP有哪些特点？\"></a>HTTP有哪些特点？</h2>\n      \n        <h3 id=\"灵活可扩展\"   >\n          <a href=\"#灵活可扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#灵活可扩展\" class=\"headerlink\" title=\"灵活可扩展\"></a>灵活可扩展</h3>\n      <p>HTTP 协议是一个“灵活可扩展”的传输协议。</p>\n\n        <h3 id=\"可靠传输\"   >\n          <a href=\"#可靠传输\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#可靠传输\" class=\"headerlink\" title=\"可靠传输\"></a>可靠传输</h3>\n      <p>HTTP 协议是一个“可靠”的传输协议</p>\n\n        <h3 id=\"应用层协议\"   >\n          <a href=\"#应用层协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h3>\n      <p>HTTP 协议是一个应用层的协议</p>\n\n        <h3 id=\"请求-应答\"   >\n          <a href=\"#请求-应答\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#请求-应答\" class=\"headerlink\" title=\"请求 - 应答\"></a>请求 - 应答</h3>\n      <p>HTTP 协议使用的是请求 - 应答通信模式</p>\n\n        <h3 id=\"无状态\"   >\n          <a href=\"#无状态\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#无状态\" class=\"headerlink\" title=\"无状态\"></a>无状态</h3>\n      <p>HTTP 协议是无状态的</p>\n<p>其他特点除了以上的五大特点，其实 HTTP 协议还可以列出非常多的特点，例如传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的。</p>\n\n        <h3 id=\"http缺点\"   >\n          <a href=\"#http缺点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#http缺点\" class=\"headerlink\" title=\"http缺点\"></a>http缺点</h3>\n      \n        <h4 id=\"明文\"   >\n          <a href=\"#明文\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#明文\" class=\"headerlink\" title=\"明文\"></a>明文</h4>\n      <p>HTTP 协议里还有一把优缺点一体的“双刃剑”，就是明文传输。</p>\n<p>“明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</p>\n\n        <h4 id=\"不安全\"   >\n          <a href=\"#不安全\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#不安全\" class=\"headerlink\" title=\"不安全\"></a>不安全</h4>\n      <p>与“明文”缺点相关但不完全等同的另一个缺点是“不安全”。</p>\n<p>安全有很多的方面，明文只是“机密”方面的一个缺点，在“身份认证”和“完整性校验”这两方面 HTTP 也是欠缺的。</p>\n\n        <h4 id=\"性能\"   >\n          <a href=\"#性能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4>\n      <p>不算差，不够好</p>\n\n        <h3 id=\"小结-4\"   >\n          <a href=\"#小结-4\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h3>\n      <ol>\n<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>\n<li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；</li>\n<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li>\n<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li>\n<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>\n<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>\n<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>\n<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>\n</ol>\n\n        <h2 id=\"课程来源\"   >\n          <a href=\"#课程来源\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#课程来源\" class=\"headerlink\" title=\"课程来源\"></a>课程来源</h2>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://time.geekbang.org/column/intro/100029001\" >https://time.geekbang.org/column/intro/100029001</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>欢迎大家订购，一块儿学习，共同进步。</p>\n","categories":["http"],"tags":["http","TCP/IP"]},{"title":"kafka数据丢失和重复消费解决方案","url":"/2021/07/08/kafka%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"<p>在使用消息中间间的过程中，经常面对的问题就是消息丢失和重复消费，本文主要记录kafka消息丢失和重复消费的解决思想，不做具体实现。</p>\n\n        <h2 id=\"生产者\"   >\n          <a href=\"#生产者\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2>\n      \n        <h3 id=\"消息丢失\"   >\n          <a href=\"#消息丢失\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#消息丢失\" class=\"headerlink\" title=\"消息丢失\"></a>消息丢失</h3>\n      \n        <h4 id=\"丢失场景\"   >\n          <a href=\"#丢失场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#丢失场景\" class=\"headerlink\" title=\"丢失场景\"></a>丢失场景</h4>\n      <a id=\"more\"></a>\n<ul>\n<li>配置文件里面,ack设置为0,也就是生产者发送之后，producer将消息存到缓存buffer之后，就会返回成功,此时分区副本(leader和follower)并不能保证落盘成功,</li>\n</ul>\n<p>此时如果出现网络抖动等问题就会导致数据丢失。</p>\n<ul>\n<li>ack设置为1,也就是生产者发送之后,只要leader接收到了,就会返回成功,follower没来及同步的时候leader挂掉,也会导致消息丢失。</li>\n</ul>\n\n        <h4 id=\"解决方案\"   >\n          <a href=\"#解决方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4>\n      <p>设置ack=all/-1,保证leader和follower分区都收到之后,再返回给生产者成功。如果其中有一个步骤异常,都会触发kafka的重试机制。</p>\n\n        <h3 id=\"重复消费\"   >\n          <a href=\"#重复消费\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重复消费\" class=\"headerlink\" title=\"重复消费\"></a>重复消费</h3>\n      \n        <h4 id=\"重复场景\"   >\n          <a href=\"#重复场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重复场景\" class=\"headerlink\" title=\"重复场景\"></a>重复场景</h4>\n      <p>生产发送的消息没有收到正确的broke响应，导致producer重试。producer发出一条消息，broke落盘以后因为网络等种种原因，发送端得到一个发送失败的响应或者网络中断，然后producer收到一个可恢复的Exception重试消息导致消息重复。</p>\n\n        <h4 id=\"解决办法\"   >\n          <a href=\"#解决办法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4>\n      <p>启动kafka的幂等性</p>\n<p>enable.idempotence=true 同时要求 ack=all 且 retries&gt;1。</p>\n<p><strong>幂等原理：</strong></p>\n<p>每个生产者producer都有一个唯一id,producer每发送一条数据,都会带上一个sequence,当消息落盘,sequence就会递增1。那么只需要判断当前消息的sequence是否大于当前最大sequence,大于就代表此条数据没有落盘过,可以正常消费。不大于就代表落盘过,这个时候重发的消息会被服务端拒掉从而避免消息重复。</p>\n\n        <h2 id=\"broker\"   >\n          <a href=\"#broker\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#broker\" class=\"headerlink\" title=\"broker\"></a>broker</h2>\n      \n        <h3 id=\"丢失场景-1\"   >\n          <a href=\"#丢失场景-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#丢失场景-1\" class=\"headerlink\" title=\"丢失场景\"></a>丢失场景</h3>\n      <ul>\n<li>ack=1,follower没来及同步的时候leader挂掉,当follower被选举为新的leader时,这部分没同步的数据就丢失了。</li>\n<li>分区副本数小于2个,导致没有足够数量的副本参与新leader选举,无法保证数据的高可用,当原leader挂了之后,没有follower被选举为leader。</li>\n</ul>\n\n        <h3 id=\"解决办法-1\"   >\n          <a href=\"#解决办法-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解决办法-1\" class=\"headerlink\" title=\"解决办法:\"></a>解决办法:</h3>\n      <ul>\n<li>ack=-1，保证leader和follower分区的数据可以落盘。</li>\n<li>保证分区副本数大于2,保证数据的高可用性</li>\n<li>设置重试次数等。</li>\n</ul>\n\n        <h2 id=\"消费者\"   >\n          <a href=\"#消费者\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2>\n      \n        <h3 id=\"消息丢失-1\"   >\n          <a href=\"#消息丢失-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#消息丢失-1\" class=\"headerlink\" title=\"消息丢失\"></a>消息丢失</h3>\n      \n        <h4 id=\"丢失场景-2\"   >\n          <a href=\"#丢失场景-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#丢失场景-2\" class=\"headerlink\" title=\"丢失场景\"></a>丢失场景</h4>\n      <p>设置的自动提交offset,当消费者已经消费到了消息,也记录了新的偏移量offset,但是后面的业务失败了或者没来得及处理就挂了。这时候因为offset已经更新了,这条消息也再消费不到了。</p>\n\n        <h4 id=\"解决办法-2\"   >\n          <a href=\"#解决办法-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解决办法-2\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4>\n      <p>设置为手动提交成功,当业务代码都执行完成之后,再进行手动提交,确保消息被真正处理到。</p>\n\n        <h3 id=\"消息重复\"   >\n          <a href=\"#消息重复\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#消息重复\" class=\"headerlink\" title=\"消息重复\"></a>消息重复</h3>\n      \n        <h4 id=\"重复场景-1\"   >\n          <a href=\"#重复场景-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#重复场景-1\" class=\"headerlink\" title=\"重复场景\"></a>重复场景</h4>\n      <p>数据消费完没有及时提交offset到broke。消息消费端在消费过程中挂掉没有及时提交offset到broke，另一个消费端启动拿之前记录的offset开始消费，由于offset的滞后性可能会导致新启动的客户端有少量重复消费。</p>\n\n        <h4 id=\"解决办法-3\"   >\n          <a href=\"#解决办法-3\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#解决办法-3\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4>\n      <ul>\n<li>设置为手动提交成功</li>\n<li>在下游程序里面做幂等</li>\n</ul>\n<p><strong>幂等的两种方法:</strong></p>\n<ol>\n<li>将唯一键存入第三方介质,要操作数据的时候先判断第三方介质(数据库或者缓存)有没有这个唯一键。</li>\n<li>将版本号(offset)存入到数据里面,然后再要操作数据的时候用这个版本号做乐观锁,当版本号大于原先的才能操作。</li>\n</ol>\n\n        <h2 id=\"参考链接\"   >\n          <a href=\"#参考链接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blog.csdn.net/qq_39188150/article/details/111415881\" >https://blog.csdn.net/qq_39188150/article/details/111415881</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n","categories":["mq"],"tags":["kafka"]},{"title":"设计模式-工厂模式golang实现","url":"/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Fgolang%E5%AE%9E%E7%8E%B0/","content":"\n        <h2 id=\"工厂模式\"   >\n          <a href=\"#工厂模式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2>\n      <p>工厂模式（Factory Pattern）属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>\n<p>golang实现</p>\n<figure class=\"highlight golang\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> factorypattern</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Shape <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tDraw() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Rectangle <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Rectangle)</span> <span class=\"title\">Draw</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;rectangle&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Square <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Square)</span> <span class=\"title\">Draw</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;square&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Circle)</span> <span class=\"title\">Draw</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;circle&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewShapeFactory 用于生成Shape接口实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewShapeFactory</span><span class=\"params\">(t <span class=\"keyword\">string</span>)</span> <span class=\"title\">Shape</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> t &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(Rectangle)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(Square)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(Circle)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>test</p>\n<figure class=\"highlight golang\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> factorypattern</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestRectangle</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\trectangle := NewShapeFactory(<span class=\"string\">&quot;rectangle&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> rectangle == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt.Fatal(<span class=\"string\">&quot;factory new failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := rectangle.Draw()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res != <span class=\"string\">&quot;rectangle&quot;</span> &#123;</span><br><span class=\"line\">\t\tt.Errorf(<span class=\"string\">&quot;error, wanted: %v, got: %v&quot;</span>, <span class=\"string\">&quot;rectangle&quot;</span>, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSquare</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tsquare := NewShapeFactory(<span class=\"string\">&quot;square&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> square == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt.Fatal(<span class=\"string\">&quot;factory new failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := square.Draw()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res != <span class=\"string\">&quot;square&quot;</span> &#123;</span><br><span class=\"line\">\t\tt.Errorf(<span class=\"string\">&quot;error, wanted: %v, got: %v&quot;</span>, <span class=\"string\">&quot;square&quot;</span>, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCircle</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcircle := NewShapeFactory(<span class=\"string\">&quot;circle&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> circle == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt.Fatal(<span class=\"string\">&quot;factory new failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := circle.Draw()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res != <span class=\"string\">&quot;circle&quot;</span> &#123;</span><br><span class=\"line\">\t\tt.Errorf(<span class=\"string\">&quot;error, wanted: %v, got: %v&quot;</span>, <span class=\"string\">&quot;circle&quot;</span>, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"代码地址\"   >\n          <a href=\"#代码地址\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h2>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/luckylsx/golang-design-mode/tree/main/01_FactoryPattern\" >https://github.com/luckylsx/golang-design-mode/tree/main/01_FactoryPattern</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"参考\"   >\n          <a href=\"#参考\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.runoob.com/design-pattern/factory-pattern.html\" >https://www.runoob.com/design-pattern/factory-pattern.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n","categories":["设计模式"],"tags":["golang","设计模式"]}]